# 尚硅谷Vue项目实战——尚品汇

**GitHub代码地址**

https://github.com/chenzhengqingzzz/shangpinhuishop

# **前端Vue核心**

用Vue开发一个前端模块可以概括为以下几个步骤：

	1. 写静态页面、拆分静态组件
	1. 发请求（API）
	1. vuex(actions/mutations/state三连操作)
	1. 组件获取仓库数据，动态展示

# 1. vue文件目录分析

**public文件夹：**静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中

**public/index.html**是一个模板文件，作用是生成项目的入口文件，webpack打包的js，css，也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html

**src文件夹（程序员代码文件夹）**

```
assets： 存放公用的静态资源（一般放置多个组件公用的静态资源）需要注意：放在assets文件夹里面的静态资源在webpack打包的时候会被当做模块打包到JS文件里面
components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中
App.vue： 唯一的根组件
main.js： 程序入口文件，最先执行的文件
babel.config.js: 配置文件（babel相关）
package.json: 项目的详细信息记录
package-lock.json: 缓存性文件（各种包的来源）
```

# 2. 项目配置

## 2.1 项目运行，浏览器自动打开

`src/package.json`

```js
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
```

## 2.2 关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）

* src根目录创建vue.config.js进行配置

`src/vue.config.js`

```js
module.exports = {
  //关闭eslint
  lintOnSave: false
  }
```

## 2.3 src文件夹简写方法，配置别名

​	`jsconfig.json`配置别名@提示【@代表的是src文件夹，这样将来文件过多，找的时候方便很多，exclude表示不可以使用该别名的文件】

```js
 {
    "compilerOptions": {
        "baseUrl": "./",
            "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },

    "exclude": [
        "node_modules",
        "dist"
    ]
 }
```

# 3. 项目路由的分析

vue-router

前端所谓路由：ket-value键值对

key：URL（地址栏中的路径）

value：相应的路由组件

注意：项目的上中下结构

路由组件：

Home首页路由组件、Search路由组件、Login登录路由组件、Register注册路由组件

非路由组件：

Header【首页、搜索页】

Footer【在首页、搜索页】，但是在登录、注册界面没有

# 4. 组件页面样式

组件页面的样式使用的是less样式，浏览器不识别该样式，需要下载相关依赖

```shell
npm i --save less less-loader
```

如果想让组件识别less样式，则需要在组件中设置

```vue
<style scoped lang="less">
```

`src/components/Header/index.vue`

```vue
<template>
  <!-- 头部 -->
  <header class="header">
    <!-- 头部的第一行 -->
    <div class="top">
      <div class="container">
        <div class="loginList">
          <p>尚品汇欢迎您！</p>
          <p>
            <span>请</span>
            <!-- 只是跳过去，没有别的业务，可以用声明式导航 -->
            <router-link to="/login">登录</router-link>
            <router-link class="register" to="/register">免费注册</router-link>
          </p>
        </div>
        <div class="typeList">
          <a href="###">我的订单</a>
          <a href="###">我的购物车</a>
          <a href="###">我的尚品汇</a>
          <a href="###">尚品汇会员</a>
          <a href="###">企业采购</a>
          <a href="###">关注尚品汇</a>
          <a href="###">合作招商</a>
          <a href="###">商家后台</a>
        </div>
      </div>
    </div>
    <!--头部第二行 搜索区域-->
    <div class="bottom">
      <h1 class="logoArea">
        <router-link class="logo" title="尚品汇" to="/home">
          <img src="./images/logo.png" alt="" />
        </router-link>
      </h1>
      <div class="searchArea">
        <form action="###" class="searchForm">
          <input
            type="text"
            id="autocomplete"
            class="input-error input-xxlarge"
          />
          <button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
            搜索
          </button>
        </form>
      </div>
    </div>
  </header>
</template>

<script>
export default {
  name: "Header",
  methods: {
    // 搜索按钮的回调函数，需要向Search路由进行跳转
    goSearch(){
      this.$router.push('/search')
    }
  },
};
</script>

<style scoped lang="less">
.header {
  & > .top {
    background-color: #eaeaea;
    height: 30px;
    line-height: 30px;

    .container {
      width: 1200px;
      margin: 0 auto;
      overflow: hidden;

      .loginList {
        float: left;

        p {
          float: left;
          margin-right: 10px;

          .register {
            border-left: 1px solid #b3aeae;
            padding: 0 5px;
            margin-left: 5px;
          }
        }
      }

      .typeList {
        float: right;

        a {
          padding: 0 10px;

          & + a {
            border-left: 1px solid #b3aeae;
          }
        }
      }
    }
  }

  & > .bottom {
    width: 1200px;
    margin: 0 auto;
    overflow: hidden;

    .logoArea {
      float: left;

      .logo {
        img {
          width: 175px;
          margin: 25px 45px;
        }
      }
    }

    .searchArea {
      float: right;
      margin-top: 35px;

      .searchForm {
        overflow: hidden;

        input {
          box-sizing: border-box;
          width: 490px;
          height: 32px;
          padding: 0px 4px;
          border: 2px solid #ea4a36;
          float: left;

          &:focus {
            outline: none;
          }
        }

        button {
          height: 32px;
          width: 68px;
          background-color: #ea4a36;
          border: none;
          color: #fff;
          float: left;
          cursor: pointer;

          &:focus {
            outline: none;
          }
        }
      }
    }
  }
}
</style>

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210225240.png" alt="image-20230420210225240" style="zoom:50%;" />

`src/components/Footer/index.vue`

```vue
<template>
  <!-- 底部 -->
  <div class="footer">
    <div class="footer-container">
      <div class="footerList">
        <div class="footerItem">
          <h4>购物指南</h4>
          <ul class="footerItemCon">
            <li>购物流程</li>
            <li>会员介绍</li>
            <li>生活旅行/团购</li>
            <li>常见问题</li>
            <li>购物指南</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>配送方式</h4>
          <ul class="footerItemCon">
            <li>上门自提</li>
            <li>211限时达</li>
            <li>配送服务查询</li>
            <li>配送费收取标准</li>
            <li>海外配送</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>支付方式</h4>
          <ul class="footerItemCon">
            <li>货到付款</li>
            <li>在线支付</li>
            <li>分期付款</li>
            <li>邮局汇款</li>
            <li>公司转账</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>售后服务</h4>
          <ul class="footerItemCon">
            <li>售后政策</li>
            <li>价格保护</li>
            <li>退款说明</li>
            <li>返修/退换货</li>
            <li>取消订单</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>特色服务</h4>
          <ul class="footerItemCon">
            <li>夺宝岛</li>
            <li>DIY装机</li>
            <li>延保服务</li>
            <li>尚品汇E卡</li>
            <li>尚品汇通信</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>帮助中心</h4>
          <img src="./images/wx_cz.jpg" />
        </div>
      </div>
      <div class="copyright">
        <ul class="helpLink">
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            联系我们
            <span class="space"></span>
          </li>
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            商家入驻
            <span class="space"></span>
          </li>
          <li>
            营销中心
            <span class="space"></span>
          </li>
          <li>
            友情链接
            <span class="space"></span>
          </li>
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            营销中心
            <span class="space"></span>
          </li>
          <li>
            友情链接
            <span class="space"></span>
          </li>
          <li>关于我们</li>
        </ul>
        <p>地址：北京市昌平区宏福科技园综合楼6层</p>
        <p>京ICP备19006430号</p>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: "Footer",
};
</script>

<style scoped lang="less" >
.footer {
  background-color: #eaeaea;

  .footer-container {
    width: 1200px;
    margin: 0 auto;
    padding: 0 15px;

    .footerList {
      padding: 20px;
      border-bottom: 1px solid #e4e1e1;
      border-top: 1px solid #e4e1e1;
      overflow: hidden;
      padding-left: 40px;

      .footerItem {
        width: 16.6666667%;
        float: left;

        h4 {
          font-size: 14px;
        }

        .footerItemCon {
          li {
            line-height: 18px;
          }
        }

        &:last-child img {
          width: 121px;
        }
      }
    }

    .copyright {
      padding: 20px;

      .helpLink {
        text-align: center;

        li {
          display: inline;

          .space {
            border-left: 1px solid #666;
            width: 1px;
            height: 13px;
            background: #666;
            margin: 8px 10px;
          }
        }
      }

      p {
        margin: 10px 0;
        text-align: center;
      }
    }
  }
}
</style>
```

![image-20230420210309954](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210309954.png)

# 4. 清除vue页面默认的样式

引入结构和样式后，会发现我们的样式有些许错位，则需要按照项目的要求清除默认样式

vue是单页面开发，我们只需要修改public下的index.html文件

```html
<link rel="stylesheet" href="reset.css">
```

`app/public/reset.css`

```css
/* @import "./iconfont.css"; */
 
/* 清除内外边距 */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote,
dl, dt, dd, ul, ol, li,
pre,
fieldset, lengend, button, input, textarea,
th, td {
    margin: 0;
    padding: 0;
}

/* 设置默认字体 */
body,
button, input, select, textarea { /* for ie */
    /*font: 12px/1 Tahoma, Helvetica, Arial, "宋体", sans-serif;*/
    font: 12px/1.3 "Microsoft YaHei",Tahoma, Helvetica, Arial, "\5b8b\4f53", sans-serif; /* 用 ascii 字符表示，使得在任何编码下都无问题 */
    color: #333;
}


h1 { font-size: 18px; /* 18px / 12px = 1.5 */ }
h2 { font-size: 16px; }
h3 { font-size: 14px; }
h4, h5, h6 { font-size: 100%; }

address, cite, dfn, em, var, i{ font-style: normal; } /* 将斜体扶正 */
b, strong{ font-weight: normal; } /* 将粗体扶细 */
code, kbd, pre, samp, tt { font-family: "Courier New", Courier, monospace; } /* 统一等宽字体 */
small { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */

/* 重置列表元素 */
ul, ol { list-style: none; }

/* 重置文本格式元素 */
a { text-decoration: none; color: #666;}


/* 重置表单元素 */
legend { color: #000; } /* for ie6 */
fieldset, img { border: none; }
button, input, select, textarea {
    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */
}

/* 重置表格元素 */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

/* 重置 hr */
hr {
    border: none;
    height: 1px;
}
.clearFix::after{
	content:"";
	display: block;
	clear:both;
}
/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */
html { overflow-y: scroll; }

a:link:hover{
    color : rgb(79, 76, 212) !important;
    text-decoration: underline;
}

/* 清除浮动 */
.clearfix::after {
    display: block;
    height: 0;
    content: "";
    clear: both;
    visibility: hidden;
}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210344299.png" alt="image-20230420210344299" style="zoom:50%;" />

# 5. pages文件夹

创建pages文件夹，并创建路由组件

`src/pages/Home/index.vue`

`src/pages/Login/index.vue`

`src/pages/Register/index.vue`

`src/pages/Search/index.vue`

## 5.1 创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册

`src/router/index.js`

```js
// 路由器，配置路由器的地方
import Vue from "vue";
import VueRouter from "vue-router";
// 使用插件
Vue.use(VueRouter)

// 引入路由组件
import Home from '../pages/Home'
import Search from '@/pages/Search'
import Login from '@/pages/Login'
import Register from '@/pages/Register'
// 配置路由
export default new VueRouter({
    routes: [
        {
            path: '/home',
            component: Home,
        },
        {
            path: '/search',
            component: Search,
        },
        {
            path: '/login',
            component: Login,
        },
        {
            path: '/register',
            component: Register,
        },
        // 重定向，在项目跑起来的时候，访问"/"，立马定向到首页
        {
            path: '*',
            redirect: '/home'
        }
    ]
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210416944.png" alt="image-20230420210416944" style="zoom:50%;" />

## 5.2 总结

路由组件和非路由组件的区别：

* 非路由组件放在components文件夹中，路由组件放在pages或view中
* 非路由组件通过标签使用，路由组件通过路由使用
* 在main.js中注册完路由，所有的路由和非路由组件身上都会拥有`$router`和`$route`属性
* `$router`：一般进行编程式路由导航进行路由跳转
* `$route`：一般获取路由信息（name path params等）

## 5.3 路由跳转方式

* 声明式路由导航：`router-link`标签，可以吧`router-link`理解为一个a标签，它也可以加class修饰

`src/components/Header/index.vue`

```vue
<!-- 只是跳过去，没有别的业务，可以用声明式导航 -->
<router-link to="/login">登录</router-link>
<router-link class="register" to="/register">免费注册</router-link>
```

* 编程式路由导航：声明式路由导航能做的编程式路由导航都能做，而且还可以处理一些业务

`src/components/Header/index.vue`

```vue
<button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
    搜索
</button>
<script>
  methods: {
    // 搜索按钮的回调函数，需要向Search路由进行跳转
    goSearch(){
      this.$router.push('/search')
    }
  },
</script>
```

# 6. Footer组件的显示与隐藏

* Footer组件在登录、注册页面是不存在的，所以要隐藏，用`v-if`或`v-show`
* 这里使用`v-show`，因为`v-if`会频繁操作DOM元素消耗性能，`v-show`只是通过样式将元素显示或隐藏
* 配置路由的时候，可以给路由配置元信息`meta`
* 在路由的元信息中定义`isShowFooter`属性，用来给`v-show`赋值，判断是否显示footer组件

`src/router/index.js`

```js
    routes: [
        {
            path: '/home',
            component: Home,
            meta: {isShowFooter: true}
        },
        {
            path: '/search',
            component: Search,
            meta: {isShowFooter: true}
        },
        {
            path: '/login',
            component: Login,
            meta: {isShowFooter: false}
        },
        {
            path: '/register',
            component: Register,
            meta: {isShowFooter: false}
        },
        // 重定向，在项目跑起来的时候，访问"/"，立马定向到首页
        {
            path: '*',
            redirect: '/home'
        }
    ]
```

`src/App.vue`

```vue
<Footer v-show="$route.meta.isShowFooter"/>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210510513.png" alt="image-20230420210510513" style="zoom:50%;" />

# 7. 路由传参

## 7.1 query、params参数

* query、params两个属性可以传递参数

  * query参数：不属于路径的一部分，类似于get请求，地址栏表现为`...8080/#/search?k1=v1&k2=v2`
  * query参数对应的路由信息：`path: "/search"`
  * params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要**占位**，地址栏表现为`...8080/#/search/v1/v2`
  * params参数对应的路由信息要修改为：`path: "/search/:keyWord"`这里的`/:keyWord`就是一个params参数的占位符

  **与路由传参的四个相关面试题：**

* 路由传递参数（对象写法）path是否可以结合params参数一起使用？

`src/components/Header/index.vue`

```js
      // 答：路由跳转传参的时候，对象的写法可以使name、path形式，但是需要注意的是：path这种写法是不能与params参数一起使用
      this.$router.push({
        path: '/search',
        params: {keyWord: this.keyWord},
        query: {k: this.keyWord.toUpperCase()}
      })
```

* 如何指定params参数可传可不传？

```js
  如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下：
  Search路由项的path已经指定要传一个keyword的params参数，如下所示：
  path: "/search/:keyword",
  执行下面进行路由跳转的代码：
  this.$router.push({name:"Search",query:{keyword:this.keyword}})
  当前跳转代码没有传递params参数
  地址栏信息：http://localhost:8080/#/?keyword=asd
  此时的地址信息少了/search
  正常的地址栏信息: http://localhost:8080/#/search?keyword=asd
  解决方法：可以通过改变path来指定params参数可传可不传 
  path: "/search/:keyword?",?表示该参数可传可不传
```

参考连接：https://blog.csdn.net/weixin_44867717/article/details/109773945

* 前面知道了params可传可不传 ，但是如果传递的是空串，如何解决？

```js
 this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''}})
 出现的问题和2中的问题相同,地址信息少了/search
 解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常
 this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''||undefined}})

```

* 路由组件能不能传递props数据？

答： 可以，有三种写法，需要在路由器中配置

`src/router/index.js`

```js
        {
            name: 'Search',
            path: '/search/:keyWord?',
            component: Search,
            meta: {isShowFooter: true},
            // 路由组件可以传递props数据
            // 1.对象写法 额外给路由组件传递一些props
            // props: {a: 1, b: 'hello'},
            // 2.布尔值写法 如果为true，会把传的params以props形式接收
            // props: true,
            // 3.函数写法 可以把params参数、query参数通过props传递给路由组件
            props: ($route) => {
                return {
                    keyWord: $route.params.keyWord,
                    k: $route.query.k
                }
            }
        },
```

## 7.2 传参方法

* 字符串形式

```js
this.$router.push('/search/' + params传的参数 + '?k=' + query传的参数)
```

* 模板字符串

```js
this.$router.push(`/search/${this.params传的参数}?k=${this.query传的参数}`)
```

**注意**： 上面字符串的传参方法可以看出params参数和’/'结合，query参数和？结合
`http://localhost:8080/#/search/asd?keyword=asd`
上面url可以看出，asd为params的值，keyword=asd为query传递的值

* 对象（常用）

```js
      this.$router.push({
        name: '路由名字',
        params: {传的参数},
        query: {传的参数}
      })
```

**注意：**以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path 

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421165927432.png" alt="image-20230421165927432" style="zoom:50%;" />

# 8. 多次执行相同的push问题

多次执行相同的push问题，控制台会发生警告

例如：使用`this.$router.push({name:‘Search’,params:{keyword:“…”||undefined}})`时，如果多次执行相同的push，控制台会出现警告

我们尝试将其打印：

`src/components/Header/index.vue`

```js
let result = this.$router.push({
		name:"Search",
		query:{keyword:this.keyword}
})
console.log(result)
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d7b3e04b2986474d8009fe970b7b2e63.png)

多次执行则会出现警告

![在这里插入图片描述](https://img-blog.csdnimg.cn/308f41adccfe4268a6a2e0b4b2d2cfd0.png)

原因：push是一个`promise`，`promise`需要传递成功和失败两个参数，我们的push中没有传递。
方法：`this.$router.push({name:‘Search’,params:{keyword:“…”||undefined}},()=>{},()=>{})`后面两项分别代表执行成功和失败的回调函数。
这种写法治标不治本，将来在别的组件中push|replace,编程式导航还是会有类似错误
push是`VueRouter.prototype`的一个方法，在router中的`index.js`重写该方法即可(看不懂也没关系，这是前端面试题)

`src/router/index.js`

```js
// 先把VueRouter原型对象上的push保存一份
let originPush = VueRouter.prototype.push
let originReplace = VueRouter.prototype.replace
// 重写push|replace方法
// 第一个参数：告诉原来的push方法，往哪里跳转，传递哪些参数
// 第二个参数：成功的回调
// 第三个参数：失败的回调
VueRouter.prototype.push = function(location, resolve, reject) {
    if (resolve && reject) {
        // call/apply的区别：
        // 相同点：都可以调用函数一次，都可以篡改函数的上下文一次
        // 不同点：call与apply传递参数：call传递参数用逗号隔开，apply方法执行，传递数组
        originPush.call(this, location, resolve, reject)
    }else{
        originPush.call(this, location, () => {}, () => {})
    }
}
VueRouter.prototype.replace = function(location, resolve, reject) {
    if (resolve && reject) {
        originReplace.call(this, location, () => {}, () => {})
    }else{
        originReplace.call(this, location, () => {}, () => {})
    }
}
```

# 9. 定义全局组件

经过分析，我们的在Home下的三级联动组件是全局组件，全局的配置都需要在`main.js`中配置

我们将三级联动组件命名为`TypeNav.vue`

`src/main.js`

```js
// 三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav'
// 第一个参数：全局组件的名字 第二个参数：哪一个组件
Vue.component(TypeNav.name, TypeNav)
```

在Home组件中使用该全局组件（以后还要在Search、Detail中使用）

```vue
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```

全局组件可以在任一页面中直接使用，不需要导入声明
下面全部商品分类就是三级联动组件

![image-20230421185308594](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185308594.png)

另外，我们也完成了主页Home的其他子组件的配置，整个静态页面搭建完成

`src/pages/Home/index.vue`

```vue
<template>
  <div>
    <!-- 三级联动全局组件 它已经注册为全局组件了，因此不需要引入 -->
    <TypeNav/>
    <!-- 其他子组件 -->
    <ListContainer/>
    <TodayRecommend/>
    <Rank/>
    <Like/>
    <Floor/>
    <Floor/>
    <Brand/>
  </div>
</template>

<script>
// 引入其余的组件
import ListContainer from '@/pages/Home/ListContainer'
import TodayRecommend from '@/pages/Home/TodayRecommend'
import Rank from '@/pages/Home/Rank'
import Like from '@/pages/Home/Like'
import Floor from '@/pages/Home/Floor'
import Brand from '@/pages/Home/Brand'
export default {
  name: 'Home',
  components: {
    ListContainer,
    TodayRecommend,
    Rank,
    Like,
    Floor,
    Brand
  }
}
</script>

<style>

</style>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185427694.png" alt="image-20230421185427694" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185441827.png" alt="image-20230421185441827" style="zoom:50%;" />

其余组件关于静态页面的代码太多，就不放在笔记上了

# 10. 封装axios

axios中文文档，包含详细信息。
https://www.kancloud.cn/yunye/axios/234845
在根目录下创建api文件夹，创建request.js文件。
内容如下，当前文件代码还比较少，后续有需求可以增添内容。

安装axios

```shell
npm i axios
```

`src/api/request.js`

```js
// 对于axios进行二次封装
import axios from "axios";

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/api
    baseURL: '/api',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
// 请求拦截器：在发请求之前，它可以检测到，并做一些事情
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token
    return config
})
// 响应拦截器
requests.interceptors.response((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器相应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

# 11. 前端通过代理解决跨域问题

在api文件夹中统一管理请求，把它们封装成函数，调用则发请求

**将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可**

`src/api/index.js`

```js
// 当前模块，所有的API接口进行统一管理
import requests from "./request";

// 三级联动的接口
// /api/product/getBaseCategoryList 是get请求 无参数
export const reqCategoryList = () => {
    // 发请求：axios发请求返回的结果是Promise对象
    // 必须把服务器响应的数据返回供其他组件和模块使用
    return requests({
        method: 'GET',
        url: '/product/getBaseCategoryList', 
    })
}
```

在main.js进行发送请求的测试

`src/main.js`

```js
// 测试
import { reqCategoryList } from "@/api";
reqCategoryList()
```

由于我们本地和需要获取数据的服务器不同源，存在跨域问题，我们的请求必定失败

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204511275.png" alt="image-20230421204511275" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204537115.png" alt="image-20230421204537115" style="zoom:50%;" />

要解决跨域问题，我们需要使用webpack为我们提供的解决跨域方案：代理服务器。

在根目录下的`vue.config.js`中配置，`proxy`为通过代理解决跨域问题，关于原理我们可以在基础课上看到

我们在二次封装axios的时候已经设置了`baseURL`为：`"/api"`，所以我们所有的请求都会携带`/api`，这里我们就将`/api`进行了转换。如果你的项目没有封装axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为`/api`。

`src/vue.config.js`

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  // 关闭eslint
  lintOnSave: false,
  // 代理服务器解决跨域
  devServer: {
    proxy: {
      // 检测到请求URL中带/api，代理服务器就会介入工作
      '/api': {
        // 真实服务器（数据存放的）的url
        target: 'http://gmall-h5-api.atguigu.cn',
        // 二次封装的axios全部请求路径已经带了api，这里不需要重写路径
        // pathRewrite: {'^/api': ''}
      }
    }
  }
})

```

跨域问题得到了解决，我们成功收到了服务器所响应的数据

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204659271.png" alt="image-20230421204659271" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204743534.png" alt="image-20230421204743534" style="zoom:50%;" />

## 12. nprogress进度条插件

当我们打开一个页面时，往往会伴随一些请求，并且会在页面的上方出现进度条。它的原理是：在我们发送请求的时候开启一个进度条，在请求成功后关闭进度条，所以只需要在`request.js`中相应的拦截器中进行配置

![在这里插入图片描述](https://img-blog.csdnimg.cn/f0df5bccfaee4274b45755b52bf40b60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

`src/api/request.js`

```js
// 对于axios进行二次封装
import axios from "axios";
// 引入进度条
import nProgress from "nprogress";
// 引入进度条样式
import "nprogress/nprogress.css"
// start：进度条开始 done：进度条结束

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/api
    baseURL: '/api',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
/**
 * @description: 请求拦截器：在发请求之前，它可以检测到，并做一些事情
 * @return {*} 
 */
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token

    // 开启进度条
    nProgress.start()

    return config
})
/**
 * @description: 响应拦截器
 * @return {*}
 */
requests.interceptors.response.use((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    // 响应成功，关闭进度条
    nProgress.done()
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器响应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

也可以通过修改依赖中的nprogress.css的background来修改进度条颜色

```css
#nprogress .bar {
  background: #29d; /* 在这里修改 */

  position: fixed;
  z-index: 1031;
  top: 0;
  left: 0;

  width: 100%;
  height: 2px;
}
```

# 13. 手动引入Vuex

首先我们确保要在Vue2中使用Vuex3（3适配2 4适配3）

`src/store/index.js`

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

//对外暴露store的一个实例
export default new Vuex.Store({
    state:{},
    mutations:{},
    actions:{},
    
})

```

如果想要在项目中使用Vuex，则需要在入口文件main.js引入并注册store

**但凡是在main.js中的Vue实例中注册的实体，在所有的组件中都会有（this.$.实体名）属性**

`src/main.js`

```js
import store from './store'
new Vue({
  render: h => h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')

```

​	我们的Vue提倡模块式开发 即那个组件用的数据就单独存放在哪个组件对应的数据流中

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424000248916.png" alt="image-20230424000248916" style="zoom:50%;" />

例如Home组件对应的数据流文件夹

`src/store/home/index.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-23 18:47:19
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-23 18:49:03
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/store/home/index.js
 * @Description: Home模块的小仓库
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */

// 仓库存储数据的地方
const state = {}
// 修改state的唯一手段
const mutations = {}
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {}
// getters理解为计算属性，更多用于简化仓库数据，让组件获取仓库的数据更加方便
const getters = {}

export default {
    namespaced: true,
    state,
    mutations,
    actions,
    getters
}
```

在Vuex中，模块化开发可以将store的代码拆分为多个模块，以便更好地管理和组织代码。而在模块化开发中，使用namespaced选项可以将模块的 actions、mutations 和 getters 封装到命名空间内，以避免不同模块之间的命名冲突。

具体来说，如果一个模块没有命名空间，它的 actions、mutations 和 getters 都会注册在全局命名空间中，这样可能会导致不同模块之间的方法名冲突，从而产生意外的结果。而使用namespaced选项后，所有的方法都会被封装到模块的命名空间下，这样就可以避免冲突，同时也更易于组织和维护代码。

因此，在模块化开发中，建议为每个模块添加namespaced选项，以便更好地管理代码和避免潜在的命名冲突

总的store：

`src/store/index.js`

```js
import Vue from "vue";
import Vuex from "vuex"
// 需要使用插件一次
Vue.use(Vuex)
// 引入小仓库
import home from './home'
import search from './search'

// 对外暴露Store类的一个实例
export default new Vuex.Store({
    // 实现Vuex仓库模块式开发存储数据
    modules: {
        home,
        search
    }
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424000410512.png" alt="image-20230424000410512" style="zoom:50%;" />

# 14. async await的使用

​	如果我们没有封装请求api，而是直接调用axios，就不需要使用async await了

案例：我们将一个axios请求封装为了函数，我们在下面代码中调用了该函数：

`src/store/home/index.js`

```js
import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d2ba586e3edd494b9bf517cb4ee86580.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

返回了一个promise,证明这是一个promise请求，但是我们想要的是其中的data数据。
没有将函数封装前我们都会通过then()回调函数拿到服务器返回的数据，现在我们将其封装了，依然可以使用then获取数据，代码如下

```js
actions:{
        categoryList(){
            let result =  reqCateGoryList().then(
                res=>{
                console.log("res")
                console.log(res)
                return res
                }
            )
            console.log("result")
            console.log(result)
        }
    }

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/ccf35a9aa6c442c7a799e474c0293afa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_15,color_FFFFFF,t_70,g_se,x_16)

由于我们的`promise`是异步请求，我们发现请求需要花费时间，但是它是异步的，所有后面的`console.log(“result”)`；`console.log(result)`会先执行，等我们的请求得到响应后，才执行`console.log(“res”)` `console.log(res)`这也符合异步的原则，但是我们如果在请求下面啊执行的是将那个请求的结果赋值给某个变量，这样就会导致被赋值的变量先执行，并且赋值为`undefined`，因为此时`promise`还没有完成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/afe1c716352248009e7289151e933391.png)

所以我们引入了`async` `await`,async写在函数名前，await写在api函数前面。await含义是async标识的函数体内的并且在await标识代码后面的代码先等待await标识的异步请求执行完，再执行。这也使得只有`reqCateGoryList`执行完，`result `得到返回值后，才会执行后面的输出操作。


![在这里插入图片描述](https://img-blog.csdnimg.cn/160a7e87520d494787915f3fe9fa4640.png)

由此我们可以通过发送请求实现三级联动菜单显示服务器数据的操作：

`src/store/home/index.js`

```js
import { reqCategoryList } from "@/api";
// 仓库存储数据的地方
const state = {
    // state中数据的默认初始值别瞎写，根据接口的返回值来决定初始值
    categoryList: []
}
// 修改state的唯一手段
const mutations = {
    UPDATECATEGORYLIST(state, categoryList){
        state.categoryList = categoryList
    }
}
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {
    /**
     * @description: 通过API里面的接口函数调用，向服务器发请求，获取服务器的数据
     * @return {Object}
     */
    async categoryList(context){
        // 要拿到Promise成功的结果，需要加上await 前面需要加上async
        let result = await reqCategoryList()
        if (result.code === 200) {
            context.commit('UPDATECATEGORYLIST', result.data)
        }else{
            console.log('请求错误');
        }
    },
    // 通过then获取response也可以实现上面一模一样的效果，都是成功的回调，都是对象
    // categoryList(context){
    //     reqCategoryList().then(
    //         (res) => {
    //         if (res.code === 200) {
    //             context.commit('UPDATECATEGORYLIST', res.data)
    //         }
    //     },
    //         (error) => {
    //             console.log(error);
    //     })
    // },
}
```

这里事先将TypeNav这个导航组件移到了全局组件文件夹中

`src/components/TypeNav/index.vue`

```vue
<template>
  <!-- 商品分类导航 -->
  <div class="type-nav">
    <div class="container">
      <h2 class="all">全部商品分类</h2>
      <nav class="nav">
        <a href="###">服装城</a>
        <a href="###">美妆馆</a>
        <a href="###">尚品汇超市</a>
        <a href="###">全球购</a>
        <a href="###">闪购</a>
        <a href="###">团购</a>
        <a href="###">有趣</a>
        <a href="###">秒杀</a>
      </nav>
      <div class="sort">
        <div class="all-sort-list2">
          <div class="item" v-for="(c1, index) in categoryList" :key="c1.categoryId">
            <h3>
              <a href="">{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix">
              <div class="subitem" v-for="(c2, index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a href="">{{c2.categoryName}}</a>
                  </dt>
                  <dd>
                    <em v-for="(c3, index) in c2.categoryChild" :key="c3.categoryId">
                      <a href="">{{c3.categoryName}}</a>
                    </em>
                  </dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapState } from 'vuex';
export default {
  name: "TypeNav",
  /**
   * @description: 组件挂载完毕：可以向服务器发送请求
   * @return {*}
   */
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    this.$store.dispatch('home/categoryList')
  },
  computed: {
    ...mapState({
      // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数将会立即执行一次
      // 注入一个参数state，其实即为大仓库的数据
      categoryList: state => state.home.categoryList
    }),
  }
};
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424175101422.png" alt="image-20230424175101422" style="zoom:50%;" />

# 15. 事件委派实现导航栏选中

需求：完成以及分类动态添加背景颜色

第一种解决方案：采用css完成（可行）

```vue
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
            >
              <h3>
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
              <div class="item-list clearfix">
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a href="">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a href="">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
```

```css
.item {...}

.item:hover {
	background-color: skyblue;
}
```

可以实现需求<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424193924422.png" alt="image-20230424193924422" style="zoom:50%;" />





第二种解决方案：利用JS完成

解决思路是首先准备个data：`currentIndex`，我们收到的一些菜单是数组里的一个个对象，里面都有索引值，当我们鼠标移入(mouseenter)的时候，就可以将预先写好的类名对应的样式`.cur`赋给目标对象模板 

```vue
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
              :class="{ cur: currentIndex == index }"
            >
              <h3 @mouseenter="changeIndex(index)" @mouseleave="leaveIndex">
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
              <div class="item-list clearfix">
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a href="">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a href="">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
<script>
import { mapState } from "vuex";
export default {
  name: "TypeNav",
  data() {
    return {
      // 存储用户鼠标移上哪一个一级分类
      currentIndex: null,
    };
  },
  /**
   * @description: 组件挂载完毕：可以向服务器发送请求
   * @return {*}
   */
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    this.$store.dispatch("home/categoryList");
  },
  computed: {
    ...mapState({
      // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数将会立即执行一次
      // 注入一个参数state，其实即为大仓库的数据
      categoryList: (state) => state.home.categoryList,
    }),
  },
  methods: {
    /**
     * @description: 鼠标进入修改响应式数据currentIndex
     * @param {*} index 鼠标移上某一个一级分类的元素索引值
     * @return {*}
     */
    changeIndex(index) {
      this.currentIndex = index;
    },
    /**
     * @description: 一级分类鼠标移出事件的回调
     * @return {*}
     */
    leaveIndex() {
      // 直接调用上面的函数，传入null更改currentIndex
      this.changeIndex(null);
    },
  },
};
</script>
<style>
          .cur {
          background-color: skyblue;
        }
</style>
```

这里有一个问题：当我们需要在我们的鼠标放入“全部商品分类”的这边区域的时候，蓝色背景还不消失，这时候我们需要用到事件委派了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424194738978.png" alt="image-20230424194738978" style="zoom:50%;" />

由于红色导航栏和下面的蓝色区域是兄弟元素，我们需要把它们放在一起并且在它们俩的外面包上一层div，并且把鼠标离开的回调放在div上，实现事件委派

```vue
      <!-- 事件委派 鼠标离开h2和h3才会让currentIndex变回-1 -->
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        <div class="sort">
          <div class="all-sort-list2">
             <h3 @mouseenter="changeIndex(index)">
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
            ...
        </div>
      </div>
```

即可实现上述效果

# 16. 通过JS控制二三级分类显示与隐藏

项目的静态页面中，一开始我们是通过CSS样式`display:block|none`来控制显示与隐藏二三级商品分类的

​        <!-- 三级联动 -->
```vue
    <div class="sort">
      <div class="all-sort-list2">
        <div
          class="item"
          v-for="(c1, index) in categoryList"
          :key="c1.categoryId"
          :class="{ cur: currentIndex == index }"
        >
          <h3 @mouseenter="changeIndex(index)">
            <a href="">{{ c1.categoryName }}</a>
          </h3>
          <!-- 二级、三级分类 -->
          <div class="item-list clearfix">
           ...
          </div>
        </div>
      </div>
    </div>
```



```less
...

&hover {
	.item-list {
		display: block;
	}
}
```

我们可以删除掉这个less语句，通过`:style="JS表达式"`的方式，将样式交给Vue管理

```vue
          <!-- 二级、三级分类 -->
          <div class="item-list clearfix" :style="{display: currentIndex == index ? 'block' : 'none'}">
           ...
          </div>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425143056530.png" alt="image-20230425143056530" style="zoom:50%;" />

# 17. loadsh插件实现防抖和节流

在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率没有限制，就会加重浏览器的负担，导致用户体验非常的糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率的同时，又不影响实际效果

lodash官网：https://www.lodashjs.com/

**节流(throttle)：在规定的间隔事件范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发**，用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码

节流函数：https://www.lodashjs.com/docs/lodash.throttle

**防抖(debounce)：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次**，用户操作很频繁，但是只执行一次，减少业务负担。

防抖函数：https://www.lodashjs.com/docs/lodash.debounce

节流和防抖简述：https://www.jianshu.com/p/c8b86b09daf0

Vue-cli中已经有了lodash模块儿，该插件提供了防抖和节流的函数，我们可以直接引入到js进行调用，当然也可以自己写【学会闭包+延时器】

例如：我们将三级联动菜单组件中的changeIndex函数设置了节流，如果操作很频繁，我们则限制50ms执行一次，由于要用到这个函数，我们必须在写methods的时候需要采用es5的键值对形式，throttle的返回值就是一个函数，所以直接使用键值对赋值，原函数的参数直接当成throttle的参数

```js
import throttle from 'lodash/throttle'
  methods: {
    /**
     * @description: 鼠标进入修改响应式数据currentIndex 没有给这个函数做节流
     * @param {*} index 鼠标移上某一个一级分类的元素索引值
     * @return {*}
     */
    // changeIndex(index) {
    //   // 正常情况（用户慢慢地操作）：鼠标进入，每一个一级分类h3都会触发鼠标进入事件
    //   // 非正常情况（用户操作很快）：本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分的h3触发了
    //   // 就是因为用户行为过快，导致浏览器反应不过来。如果当前回调函数中有大量业务，就会出现卡顿
    //   this.currentIndex = index;
    // },
    
    // es6写法无法操作lodash的对象“_” 所以我们必须用es5的key:value写法
    /**
     * @description: 三级联动菜单中一级分类选中的节流
     * @param {Function} 需要做节流的函数
     * @param {[wait=0]} 在 wait 秒内最多执行 Function 函数
     * @return {*}
     */
    changeIndex: throttle(function(index){
      this.currentIndex = index
    }, 50),

    /**
     * @description: 一级分类鼠标移出事件的回调
     * @return {*}
     */
    leaveIndex() {
      // 直接调用上面的函数，传入null更改currentIndex
      this.changeIndex(null);
    },
  },
```

这样就可以节省性能提升用户体验