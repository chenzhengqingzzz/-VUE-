# 尚硅谷Vue项目实战——尚品汇

**GitHub代码地址**

https://github.com/chenzhengqingzzz/shangpinhuishop

# **前端Vue核心**

用Vue开发一个前端模块可以概括为以下几个步骤：

	1. 写静态页面、拆分静态组件
	1. 发请求（API）
	1. vuex(actions/mutations/state三连操作)
	1. 组件获取仓库数据，动态展示

# 1. vue文件目录分析

**public文件夹：**静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中

**public/index.html**是一个模板文件，作用是生成项目的入口文件，webpack打包的js，css，也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html

**src文件夹（程序员代码文件夹）**

```
assets： 存放公用的静态资源（一般放置多个组件公用的静态资源）需要注意：放在assets文件夹里面的静态资源在webpack打包的时候会被当做模块打包到JS文件里面
components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中
App.vue： 唯一的根组件
main.js： 程序入口文件，最先执行的文件
babel.config.js: 配置文件（babel相关）
package.json: 项目的详细信息记录
package-lock.json: 缓存性文件（各种包的来源）
```

# 2. 项目配置

## 2.1 项目运行，浏览器自动打开

`src/package.json`

```js
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
```

## 2.2 关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）

* src根目录创建vue.config.js进行配置

`src/vue.config.js`

```js
module.exports = {
  //关闭eslint
  lintOnSave: false
  }
```

## 2.3 src文件夹简写方法，配置别名

​	`jsconfig.json`配置别名@提示【@代表的是src文件夹，这样将来文件过多，找的时候方便很多，exclude表示不可以使用该别名的文件】

```js
 {
    "compilerOptions": {
        "baseUrl": "./",
            "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },

    "exclude": [
        "node_modules",
        "dist"
    ]
 }
```

# 3. 项目路由的分析

vue-router

前端所谓路由：ket-value键值对

key：URL（地址栏中的路径）

value：相应的路由组件

注意：项目的上中下结构

路由组件：

Home首页路由组件、Search路由组件、Login登录路由组件、Register注册路由组件

非路由组件：

Header【首页、搜索页】

Footer【在首页、搜索页】，但是在登录、注册界面没有

# 4. 组件页面样式

组件页面的样式使用的是less样式，浏览器不识别该样式，需要下载相关依赖

```shell
npm i --save less less-loader
```

如果想让组件识别less样式，则需要在组件中设置

```vue
<style scoped lang="less">
```

`src/components/Header/index.vue`

```vue
<template>
  <!-- 头部 -->
  <header class="header">
    <!-- 头部的第一行 -->
    <div class="top">
      <div class="container">
        <div class="loginList">
          <p>尚品汇欢迎您！</p>
          <p>
            <span>请</span>
            <!-- 只是跳过去，没有别的业务，可以用声明式导航 -->
            <router-link to="/login">登录</router-link>
            <router-link class="register" to="/register">免费注册</router-link>
          </p>
        </div>
        <div class="typeList">
          <a href="###">我的订单</a>
          <a href="###">我的购物车</a>
          <a href="###">我的尚品汇</a>
          <a href="###">尚品汇会员</a>
          <a href="###">企业采购</a>
          <a href="###">关注尚品汇</a>
          <a href="###">合作招商</a>
          <a href="###">商家后台</a>
        </div>
      </div>
    </div>
    <!--头部第二行 搜索区域-->
    <div class="bottom">
      <h1 class="logoArea">
        <router-link class="logo" title="尚品汇" to="/home">
          <img src="./images/logo.png" alt="" />
        </router-link>
      </h1>
      <div class="searchArea">
        <form action="###" class="searchForm">
          <input
            type="text"
            id="autocomplete"
            class="input-error input-xxlarge"
          />
          <button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
            搜索
          </button>
        </form>
      </div>
    </div>
  </header>
</template>

<script>
export default {
  name: "Header",
  methods: {
    // 搜索按钮的回调函数，需要向Search路由进行跳转
    goSearch(){
      this.$router.push('/search')
    }
  },
};
</script>

<style scoped lang="less">
.header {
  & > .top {
    background-color: #eaeaea;
    height: 30px;
    line-height: 30px;

    .container {
      width: 1200px;
      margin: 0 auto;
      overflow: hidden;

      .loginList {
        float: left;

        p {
          float: left;
          margin-right: 10px;

          .register {
            border-left: 1px solid #b3aeae;
            padding: 0 5px;
            margin-left: 5px;
          }
        }
      }

      .typeList {
        float: right;

        a {
          padding: 0 10px;

          & + a {
            border-left: 1px solid #b3aeae;
          }
        }
      }
    }
  }

  & > .bottom {
    width: 1200px;
    margin: 0 auto;
    overflow: hidden;

    .logoArea {
      float: left;

      .logo {
        img {
          width: 175px;
          margin: 25px 45px;
        }
      }
    }

    .searchArea {
      float: right;
      margin-top: 35px;

      .searchForm {
        overflow: hidden;

        input {
          box-sizing: border-box;
          width: 490px;
          height: 32px;
          padding: 0px 4px;
          border: 2px solid #ea4a36;
          float: left;

          &:focus {
            outline: none;
          }
        }

        button {
          height: 32px;
          width: 68px;
          background-color: #ea4a36;
          border: none;
          color: #fff;
          float: left;
          cursor: pointer;

          &:focus {
            outline: none;
          }
        }
      }
    }
  }
}
</style>

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210225240.png" alt="image-20230420210225240" style="zoom:50%;" />

`src/components/Footer/index.vue`

```vue
<template>
  <!-- 底部 -->
  <div class="footer">
    <div class="footer-container">
      <div class="footerList">
        <div class="footerItem">
          <h4>购物指南</h4>
          <ul class="footerItemCon">
            <li>购物流程</li>
            <li>会员介绍</li>
            <li>生活旅行/团购</li>
            <li>常见问题</li>
            <li>购物指南</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>配送方式</h4>
          <ul class="footerItemCon">
            <li>上门自提</li>
            <li>211限时达</li>
            <li>配送服务查询</li>
            <li>配送费收取标准</li>
            <li>海外配送</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>支付方式</h4>
          <ul class="footerItemCon">
            <li>货到付款</li>
            <li>在线支付</li>
            <li>分期付款</li>
            <li>邮局汇款</li>
            <li>公司转账</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>售后服务</h4>
          <ul class="footerItemCon">
            <li>售后政策</li>
            <li>价格保护</li>
            <li>退款说明</li>
            <li>返修/退换货</li>
            <li>取消订单</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>特色服务</h4>
          <ul class="footerItemCon">
            <li>夺宝岛</li>
            <li>DIY装机</li>
            <li>延保服务</li>
            <li>尚品汇E卡</li>
            <li>尚品汇通信</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>帮助中心</h4>
          <img src="./images/wx_cz.jpg" />
        </div>
      </div>
      <div class="copyright">
        <ul class="helpLink">
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            联系我们
            <span class="space"></span>
          </li>
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            商家入驻
            <span class="space"></span>
          </li>
          <li>
            营销中心
            <span class="space"></span>
          </li>
          <li>
            友情链接
            <span class="space"></span>
          </li>
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            营销中心
            <span class="space"></span>
          </li>
          <li>
            友情链接
            <span class="space"></span>
          </li>
          <li>关于我们</li>
        </ul>
        <p>地址：北京市昌平区宏福科技园综合楼6层</p>
        <p>京ICP备19006430号</p>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: "Footer",
};
</script>

<style scoped lang="less" >
.footer {
  background-color: #eaeaea;

  .footer-container {
    width: 1200px;
    margin: 0 auto;
    padding: 0 15px;

    .footerList {
      padding: 20px;
      border-bottom: 1px solid #e4e1e1;
      border-top: 1px solid #e4e1e1;
      overflow: hidden;
      padding-left: 40px;

      .footerItem {
        width: 16.6666667%;
        float: left;

        h4 {
          font-size: 14px;
        }

        .footerItemCon {
          li {
            line-height: 18px;
          }
        }

        &:last-child img {
          width: 121px;
        }
      }
    }

    .copyright {
      padding: 20px;

      .helpLink {
        text-align: center;

        li {
          display: inline;

          .space {
            border-left: 1px solid #666;
            width: 1px;
            height: 13px;
            background: #666;
            margin: 8px 10px;
          }
        }
      }

      p {
        margin: 10px 0;
        text-align: center;
      }
    }
  }
}
</style>
```

![image-20230420210309954](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210309954.png)

# 4. 清除vue页面默认的样式

引入结构和样式后，会发现我们的样式有些许错位，则需要按照项目的要求清除默认样式

vue是单页面开发，我们只需要修改public下的index.html文件

```html
<link rel="stylesheet" href="reset.css">
```

`app/public/reset.css`

```css
/* @import "./iconfont.css"; */
 
/* 清除内外边距 */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote,
dl, dt, dd, ul, ol, li,
pre,
fieldset, lengend, button, input, textarea,
th, td {
    margin: 0;
    padding: 0;
}

/* 设置默认字体 */
body,
button, input, select, textarea { /* for ie */
    /*font: 12px/1 Tahoma, Helvetica, Arial, "宋体", sans-serif;*/
    font: 12px/1.3 "Microsoft YaHei",Tahoma, Helvetica, Arial, "\5b8b\4f53", sans-serif; /* 用 ascii 字符表示，使得在任何编码下都无问题 */
    color: #333;
}


h1 { font-size: 18px; /* 18px / 12px = 1.5 */ }
h2 { font-size: 16px; }
h3 { font-size: 14px; }
h4, h5, h6 { font-size: 100%; }

address, cite, dfn, em, var, i{ font-style: normal; } /* 将斜体扶正 */
b, strong{ font-weight: normal; } /* 将粗体扶细 */
code, kbd, pre, samp, tt { font-family: "Courier New", Courier, monospace; } /* 统一等宽字体 */
small { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */

/* 重置列表元素 */
ul, ol { list-style: none; }

/* 重置文本格式元素 */
a { text-decoration: none; color: #666;}


/* 重置表单元素 */
legend { color: #000; } /* for ie6 */
fieldset, img { border: none; }
button, input, select, textarea {
    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */
}

/* 重置表格元素 */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

/* 重置 hr */
hr {
    border: none;
    height: 1px;
}
.clearFix::after{
	content:"";
	display: block;
	clear:both;
}
/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */
html { overflow-y: scroll; }

a:link:hover{
    color : rgb(79, 76, 212) !important;
    text-decoration: underline;
}

/* 清除浮动 */
.clearfix::after {
    display: block;
    height: 0;
    content: "";
    clear: both;
    visibility: hidden;
}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210344299.png" alt="image-20230420210344299" style="zoom:50%;" />

# 5. pages文件夹

创建pages文件夹，并创建路由组件

`src/pages/Home/index.vue`

`src/pages/Login/index.vue`

`src/pages/Register/index.vue`

`src/pages/Search/index.vue`

## 5.1 创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册

`src/router/index.js`

```js
// 路由器，配置路由器的地方
import Vue from "vue";
import VueRouter from "vue-router";
// 使用插件
Vue.use(VueRouter)

// 引入路由组件
import Home from '../pages/Home'
import Search from '@/pages/Search'
import Login from '@/pages/Login'
import Register from '@/pages/Register'
// 配置路由
export default new VueRouter({
    routes: [
        {
            path: '/home',
            component: Home,
        },
        {
            path: '/search',
            component: Search,
        },
        {
            path: '/login',
            component: Login,
        },
        {
            path: '/register',
            component: Register,
        },
        // 重定向，在项目跑起来的时候，访问"/"，立马定向到首页
        {
            path: '*',
            redirect: '/home'
        }
    ]
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210416944.png" alt="image-20230420210416944" style="zoom:50%;" />

## 5.2 总结

路由组件和非路由组件的区别：

* 非路由组件放在components文件夹中，路由组件放在pages或view中
* 非路由组件通过标签使用，路由组件通过路由使用
* 在main.js中注册完路由，所有的路由和非路由组件身上都会拥有`$router`和`$route`属性
* `$router`：一般进行编程式路由导航进行路由跳转
* `$route`：一般获取路由信息（name path params等）

## 5.3 路由跳转方式

* 声明式路由导航：`router-link`标签，可以吧`router-link`理解为一个a标签，它也可以加class修饰

`src/components/Header/index.vue`

```vue
<!-- 只是跳过去，没有别的业务，可以用声明式导航 -->
<router-link to="/login">登录</router-link>
<router-link class="register" to="/register">免费注册</router-link>
```

* 编程式路由导航：声明式路由导航能做的编程式路由导航都能做，而且还可以处理一些业务

`src/components/Header/index.vue`

```vue
<button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
    搜索
</button>
<script>
  methods: {
    // 搜索按钮的回调函数，需要向Search路由进行跳转
    goSearch(){
      this.$router.push('/search')
    }
  },
</script>
```

# 6. Footer组件的显示与隐藏

* Footer组件在登录、注册页面是不存在的，所以要隐藏，用`v-if`或`v-show`
* 这里使用`v-show`，因为`v-if`会频繁操作DOM元素消耗性能，`v-show`只是通过样式将元素显示或隐藏
* 配置路由的时候，可以给路由配置元信息`meta`
* 在路由的元信息中定义`isShowFooter`属性，用来给`v-show`赋值，判断是否显示footer组件

`src/router/index.js`

```js
    routes: [
        {
            path: '/home',
            component: Home,
            meta: {isShowFooter: true}
        },
        {
            path: '/search',
            component: Search,
            meta: {isShowFooter: true}
        },
        {
            path: '/login',
            component: Login,
            meta: {isShowFooter: false}
        },
        {
            path: '/register',
            component: Register,
            meta: {isShowFooter: false}
        },
        // 重定向，在项目跑起来的时候，访问"/"，立马定向到首页
        {
            path: '*',
            redirect: '/home'
        }
    ]
```

`src/App.vue`

```vue
<Footer v-show="$route.meta.isShowFooter"/>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210510513.png" alt="image-20230420210510513" style="zoom:50%;" />

# 7. 路由传参

## 7.1 query、params参数

* query、params两个属性可以传递参数

  * query参数：不属于路径的一部分，类似于get请求，地址栏表现为`...8080/#/search?k1=v1&k2=v2`
  * query参数对应的路由信息：`path: "/search"`
  * params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要**占位**，地址栏表现为`...8080/#/search/v1/v2`
  * params参数对应的路由信息要修改为：`path: "/search/:keyWord"`这里的`/:keyWord`就是一个params参数的占位符

  **与路由传参的四个相关面试题：**

* 路由传递参数（对象写法）path是否可以结合params参数一起使用？

`src/components/Header/index.vue`

```js
      // 答：路由跳转传参的时候，对象的写法可以使name、path形式，但是需要注意的是：path这种写法是不能与params参数一起使用
      this.$router.push({
        path: '/search',
        params: {keyWord: this.keyWord},
        query: {k: this.keyWord.toUpperCase()}
      })
```

* 如何指定params参数可传可不传？

```js
  如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下：
  Search路由项的path已经指定要传一个keyword的params参数，如下所示：
  path: "/search/:keyword",
  执行下面进行路由跳转的代码：
  this.$router.push({name:"Search",query:{keyword:this.keyword}})
  当前跳转代码没有传递params参数
  地址栏信息：http://localhost:8080/#/?keyword=asd
  此时的地址信息少了/search
  正常的地址栏信息: http://localhost:8080/#/search?keyword=asd
  解决方法：可以通过改变path来指定params参数可传可不传 
  path: "/search/:keyword?",?表示该参数可传可不传
```

参考连接：https://blog.csdn.net/weixin_44867717/article/details/109773945

* 前面知道了params可传可不传 ，但是如果传递的是空串，如何解决？

```js
 this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''}})
 出现的问题和2中的问题相同,地址信息少了/search
 解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常
 this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''||undefined}})

```

* 路由组件能不能传递props数据？

答： 可以，有三种写法，需要在路由器中配置

`src/router/index.js`

```js
        {
            name: 'Search',
            path: '/search/:keyWord?',
            component: Search,
            meta: {isShowFooter: true},
            // 路由组件可以传递props数据
            // 1.对象写法 额外给路由组件传递一些props
            // props: {a: 1, b: 'hello'},
            // 2.布尔值写法 如果为true，会把传的params以props形式接收
            // props: true,
            // 3.函数写法 可以把params参数、query参数通过props传递给路由组件
            props: ($route) => {
                return {
                    keyWord: $route.params.keyWord,
                    k: $route.query.k
                }
            }
        },
```

## 7.2 传参方法

* 字符串形式

```js
this.$router.push('/search/' + params传的参数 + '?k=' + query传的参数)
```

* 模板字符串

```js
this.$router.push(`/search/${this.params传的参数}?k=${this.query传的参数}`)
```

**注意**： 上面字符串的传参方法可以看出params参数和’/'结合，query参数和？结合
`http://localhost:8080/#/search/asd?keyword=asd`
上面url可以看出，asd为params的值，keyword=asd为query传递的值

* 对象（常用）

```js
      this.$router.push({
        name: '路由名字',
        params: {传的参数},
        query: {传的参数}
      })
```

**注意：**以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path 

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421165927432.png" alt="image-20230421165927432" style="zoom:50%;" />

# 8. 多次执行相同的push问题

多次执行相同的push问题，控制台会发生警告

例如：使用`this.$router.push({name:‘Search’,params:{keyword:“…”||undefined}})`时，如果多次执行相同的push，控制台会出现警告

我们尝试将其打印：

`src/components/Header/index.vue`

```js
let result = this.$router.push({
		name:"Search",
		query:{keyword:this.keyword}
})
console.log(result)
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d7b3e04b2986474d8009fe970b7b2e63.png)

多次执行则会出现警告

![在这里插入图片描述](https://img-blog.csdnimg.cn/308f41adccfe4268a6a2e0b4b2d2cfd0.png)

原因：push是一个`promise`，`promise`需要传递成功和失败两个参数，我们的push中没有传递。
方法：`this.$router.push({name:‘Search’,params:{keyword:“…”||undefined}},()=>{},()=>{})`后面两项分别代表执行成功和失败的回调函数。
这种写法治标不治本，将来在别的组件中push|replace,编程式导航还是会有类似错误
push是`VueRouter.prototype`的一个方法，在router中的`index.js`重写该方法即可(看不懂也没关系，这是前端面试题)

`src/router/index.js`

```js
// 先把VueRouter原型对象上的push保存一份
let originPush = VueRouter.prototype.push
let originReplace = VueRouter.prototype.replace
// 重写push|replace方法
// 第一个参数：告诉原来的push方法，往哪里跳转，传递哪些参数
// 第二个参数：成功的回调
// 第三个参数：失败的回调
VueRouter.prototype.push = function(location, resolve, reject) {
    if (resolve && reject) {
        // call/apply的区别：
        // 相同点：都可以调用函数一次，都可以篡改函数的上下文一次
        // 不同点：call与apply传递参数：call传递参数用逗号隔开，apply方法执行，传递数组
        originPush.call(this, location, resolve, reject)
    }else{
        originPush.call(this, location, () => {}, () => {})
    }
}
VueRouter.prototype.replace = function(location, resolve, reject) {
    if (resolve && reject) {
        originReplace.call(this, location, () => {}, () => {})
    }else{
        originReplace.call(this, location, () => {}, () => {})
    }
}
```

# 9. 定义全局组件

经过分析，我们的在Home下的三级联动组件是全局组件，全局的配置都需要在`main.js`中配置

我们将三级联动组件命名为`TypeNav.vue`

`src/main.js`

```js
// 三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav'
// 第一个参数：全局组件的名字 第二个参数：哪一个组件
Vue.component(TypeNav.name, TypeNav)
```

在Home组件中使用该全局组件（以后还要在Search、Detail中使用）

```vue
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```

全局组件可以在任一页面中直接使用，不需要导入声明
下面全部商品分类就是三级联动组件

![image-20230421185308594](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185308594.png)

另外，我们也完成了主页Home的其他子组件的配置，整个静态页面搭建完成

`src/pages/Home/index.vue`

```vue
<template>
  <div>
    <!-- 三级联动全局组件 它已经注册为全局组件了，因此不需要引入 -->
    <TypeNav/>
    <!-- 其他子组件 -->
    <ListContainer/>
    <TodayRecommend/>
    <Rank/>
    <Like/>
    <Floor/>
    <Floor/>
    <Brand/>
  </div>
</template>

<script>
// 引入其余的组件
import ListContainer from '@/pages/Home/ListContainer'
import TodayRecommend from '@/pages/Home/TodayRecommend'
import Rank from '@/pages/Home/Rank'
import Like from '@/pages/Home/Like'
import Floor from '@/pages/Home/Floor'
import Brand from '@/pages/Home/Brand'
export default {
  name: 'Home',
  components: {
    ListContainer,
    TodayRecommend,
    Rank,
    Like,
    Floor,
    Brand
  }
}
</script>

<style>

</style>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185427694.png" alt="image-20230421185427694" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185441827.png" alt="image-20230421185441827" style="zoom:50%;" />

其余组件关于静态页面的代码太多，就不放在笔记上了

# 10. 封装axios

axios中文文档，包含详细信息。
https://www.kancloud.cn/yunye/axios/234845
在根目录下创建api文件夹，创建request.js文件。
内容如下，当前文件代码还比较少，后续有需求可以增添内容。

安装axios

```shell
npm i axios
```

`src/api/request.js`

```js
// 对于axios进行二次封装
import axios from "axios";

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/api
    baseURL: '/api',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
// 请求拦截器：在发请求之前，它可以检测到，并做一些事情
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token
    return config
})
// 响应拦截器
requests.interceptors.response((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器相应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

# 11. 前端通过代理解决跨域问题

在api文件夹中统一管理请求，把它们封装成函数，调用则发请求

**将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可**

`src/api/index.js`

```js
// 当前模块，所有的API接口进行统一管理
import requests from "./request";

// 三级联动的接口
// /api/product/getBaseCategoryList 是get请求 无参数
export const reqCategoryList = () => {
    // 发请求：axios发请求返回的结果是Promise对象
    // 必须把服务器响应的数据返回供其他组件和模块使用
    return requests({
        method: 'GET',
        url: '/product/getBaseCategoryList', 
    })
}
```

在main.js进行发送请求的测试

`src/main.js`

```js
// 测试
import { reqCategoryList } from "@/api";
reqCategoryList()
```

由于我们本地和需要获取数据的服务器不同源，存在跨域问题，我们的请求必定失败

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204511275.png" alt="image-20230421204511275" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204537115.png" alt="image-20230421204537115" style="zoom:50%;" />

要解决跨域问题，我们需要使用webpack为我们提供的解决跨域方案：代理服务器。

在根目录下的`vue.config.js`中配置，`proxy`为通过代理解决跨域问题，关于原理我们可以在基础课上看到

我们在二次封装axios的时候已经设置了`baseURL`为：`"/api"`，所以我们所有的请求都会携带`/api`，这里我们就将`/api`进行了转换。如果你的项目没有封装axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为`/api`。

`src/vue.config.js`

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  // 关闭eslint
  lintOnSave: false,
  // 代理服务器解决跨域
  devServer: {
    proxy: {
      // 检测到请求URL中带/api，代理服务器就会介入工作
      '/api': {
        // 真实服务器（数据存放的）的url
        target: 'http://gmall-h5-api.atguigu.cn',
        // 二次封装的axios全部请求路径已经带了api，这里不需要重写路径
        // pathRewrite: {'^/api': ''}
      }
    }
  }
})

```

跨域问题得到了解决，我们成功收到了服务器所响应的数据

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204659271.png" alt="image-20230421204659271" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204743534.png" alt="image-20230421204743534" style="zoom:50%;" />

## 12. nprogress进度条插件

当我们打开一个页面时，往往会伴随一些请求，并且会在页面的上方出现进度条。它的原理是：在我们发送请求的时候开启一个进度条，在请求成功后关闭进度条，所以只需要在`request.js`中相应的拦截器中进行配置

![在这里插入图片描述](https://img-blog.csdnimg.cn/f0df5bccfaee4274b45755b52bf40b60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

`src/api/request.js`

```js
// 对于axios进行二次封装
import axios from "axios";
// 引入进度条
import nProgress from "nprogress";
// 引入进度条样式
import "nprogress/nprogress.css"
// start：进度条开始 done：进度条结束

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/api
    baseURL: '/api',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
/**
 * @description: 请求拦截器：在发请求之前，它可以检测到，并做一些事情
 * @return {*} 
 */
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token

    // 开启进度条
    nProgress.start()

    return config
})
/**
 * @description: 响应拦截器
 * @return {*}
 */
requests.interceptors.response.use((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    // 响应成功，关闭进度条
    nProgress.done()
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器响应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

也可以通过修改依赖中的nprogress.css的background来修改进度条颜色

```css
#nprogress .bar {
  background: #29d; /* 在这里修改 */

  position: fixed;
  z-index: 1031;
  top: 0;
  left: 0;

  width: 100%;
  height: 2px;
}
```

# 13. 手动引入Vuex

首先我们确保要在Vue2中使用Vuex3（3适配2 4适配3）

`src/store/index.js`

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

//对外暴露store的一个实例
export default new Vuex.Store({
    state:{},
    mutations:{},
    actions:{},
    
})

```

如果想要在项目中使用Vuex，则需要在入口文件main.js引入并注册store

**但凡是在main.js中的Vue实例中注册的实体，在所有的组件中都会有（this.$.实体名）属性**

`src/main.js`

```js
import store from './store'
new Vue({
  render: h => h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')

```

​	我们的Vue提倡模块式开发 即那个组件用的数据就单独存放在哪个组件对应的数据流中

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424000248916.png" alt="image-20230424000248916" style="zoom:50%;" />

例如Home组件对应的数据流文件夹

`src/store/home/index.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-23 18:47:19
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-23 18:49:03
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/store/home/index.js
 * @Description: Home模块的小仓库
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */

// 仓库存储数据的地方
const state = {}
// 修改state的唯一手段
const mutations = {}
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {}
// getters理解为计算属性，更多用于简化仓库数据，让组件获取仓库的数据更加方便
const getters = {}

export default {
    namespaced: true,
    state,
    mutations,
    actions,
    getters
}
```

在Vuex中，模块化开发可以将store的代码拆分为多个模块，以便更好地管理和组织代码。而在模块化开发中，使用namespaced选项可以将模块的 actions、mutations 和 getters 封装到命名空间内，以避免不同模块之间的命名冲突。

具体来说，如果一个模块没有命名空间，它的 actions、mutations 和 getters 都会注册在全局命名空间中，这样可能会导致不同模块之间的方法名冲突，从而产生意外的结果。而使用namespaced选项后，所有的方法都会被封装到模块的命名空间下，这样就可以避免冲突，同时也更易于组织和维护代码。

因此，在模块化开发中，建议为每个模块添加namespaced选项，以便更好地管理代码和避免潜在的命名冲突

总的store：

`src/store/index.js`

```js
import Vue from "vue";
import Vuex from "vuex"
// 需要使用插件一次
Vue.use(Vuex)
// 引入小仓库
import home from './home'
import search from './search'

// 对外暴露Store类的一个实例
export default new Vuex.Store({
    // 实现Vuex仓库模块式开发存储数据
    modules: {
        home,
        search
    }
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424000410512.png" alt="image-20230424000410512" style="zoom:50%;" />

# 14. async await的使用

​	如果我们没有封装请求api，而是直接调用axios，就不需要使用async await了

案例：我们将一个axios请求封装为了函数，我们在下面代码中调用了该函数：

`src/store/home/index.js`

```js
import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d2ba586e3edd494b9bf517cb4ee86580.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

返回了一个promise,证明这是一个promise请求，但是我们想要的是其中的data数据。
没有将函数封装前我们都会通过then()回调函数拿到服务器返回的数据，现在我们将其封装了，依然可以使用then获取数据，代码如下

```js
actions:{
        categoryList(){
            let result =  reqCateGoryList().then(
                res=>{
                console.log("res")
                console.log(res)
                return res
                }
            )
            console.log("result")
            console.log(result)
        }
    }

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/ccf35a9aa6c442c7a799e474c0293afa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_15,color_FFFFFF,t_70,g_se,x_16)

由于我们的`promise`是异步请求，我们发现请求需要花费时间，但是它是异步的，所有后面的`console.log(“result”)`；`console.log(result)`会先执行，等我们的请求得到响应后，才执行`console.log(“res”)` `console.log(res)`这也符合异步的原则，但是我们如果在请求下面啊执行的是将那个请求的结果赋值给某个变量，这样就会导致被赋值的变量先执行，并且赋值为`undefined`，因为此时`promise`还没有完成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/afe1c716352248009e7289151e933391.png)

所以我们引入了`async` `await`,async写在函数名前，await写在api函数前面。await含义是async标识的函数体内的并且在await标识代码后面的代码先等待await标识的异步请求执行完，再执行。这也使得只有`reqCateGoryList`执行完，`result `得到返回值后，才会执行后面的输出操作。


![在这里插入图片描述](https://img-blog.csdnimg.cn/160a7e87520d494787915f3fe9fa4640.png)

由此我们可以通过发送请求实现三级联动菜单显示服务器数据的操作：

`src/store/home/index.js`

```js
import { reqCategoryList } from "@/api";
// 仓库存储数据的地方
const state = {
    // state中数据的默认初始值别瞎写，根据接口的返回值来决定初始值
    categoryList: []
}
// 修改state的唯一手段
const mutations = {
    UPDATECATEGORYLIST(state, categoryList){
        state.categoryList = categoryList
    }
}
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {
    /**
     * @description: 通过API里面的接口函数调用，向服务器发请求，获取服务器的数据
     * @return {Object}
     */
    async categoryList(context){
        // 要拿到Promise成功的结果，需要加上await 前面需要加上async
        let result = await reqCategoryList()
        if (result.code === 200) {
            context.commit('UPDATECATEGORYLIST', result.data)
        }else{
            console.log('请求错误');
        }
    },
    // 通过then获取response也可以实现上面一模一样的效果，都是成功的回调，都是对象
    // categoryList(context){
    //     reqCategoryList().then(
    //         (res) => {
    //         if (res.code === 200) {
    //             context.commit('UPDATECATEGORYLIST', res.data)
    //         }
    //     },
    //         (error) => {
    //             console.log(error);
    //     })
    // },
}
```

这里事先将TypeNav这个导航组件移到了全局组件文件夹中

`src/components/TypeNav/index.vue`

```vue
<template>
  <!-- 商品分类导航 -->
  <div class="type-nav">
    <div class="container">
      <h2 class="all">全部商品分类</h2>
      <nav class="nav">
        <a href="###">服装城</a>
        <a href="###">美妆馆</a>
        <a href="###">尚品汇超市</a>
        <a href="###">全球购</a>
        <a href="###">闪购</a>
        <a href="###">团购</a>
        <a href="###">有趣</a>
        <a href="###">秒杀</a>
      </nav>
      <div class="sort">
        <div class="all-sort-list2">
          <div class="item" v-for="(c1, index) in categoryList" :key="c1.categoryId">
            <h3>
              <a href="">{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix">
              <div class="subitem" v-for="(c2, index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a href="">{{c2.categoryName}}</a>
                  </dt>
                  <dd>
                    <em v-for="(c3, index) in c2.categoryChild" :key="c3.categoryId">
                      <a href="">{{c3.categoryName}}</a>
                    </em>
                  </dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapState } from 'vuex';
export default {
  name: "TypeNav",
  /**
   * @description: 组件挂载完毕：可以向服务器发送请求
   * @return {*}
   */
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    this.$store.dispatch('home/categoryList')
  },
  computed: {
    ...mapState({
      // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数将会立即执行一次
      // 注入一个参数state，其实即为大仓库的数据
      categoryList: state => state.home.categoryList
    }),
  }
};
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424175101422.png" alt="image-20230424175101422" style="zoom:50%;" />

# 15. 事件委派实现导航栏选中

需求：完成以及分类动态添加背景颜色

第一种解决方案：采用css完成（可行）

```vue
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
            >
              <h3>
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
              <div class="item-list clearfix">
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a href="">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a href="">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
```

```css
.item {...}

.item:hover {
	background-color: skyblue;
}
```

可以实现需求<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424193924422.png" alt="image-20230424193924422" style="zoom:50%;" />





第二种解决方案：利用JS完成

解决思路是首先准备个data：`currentIndex`，我们收到的一些菜单是数组里的一个个对象，里面都有索引值，当我们鼠标移入(mouseenter)的时候，就可以将预先写好的类名对应的样式`.cur`赋给目标对象模板 

```vue
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
              :class="{ cur: currentIndex == index }"
            >
              <h3 @mouseenter="changeIndex(index)" @mouseleave="leaveIndex">
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
              <div class="item-list clearfix">
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a href="">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a href="">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
<script>
import { mapState } from "vuex";
export default {
  name: "TypeNav",
  data() {
    return {
      // 存储用户鼠标移上哪一个一级分类
      currentIndex: null,
    };
  },
  /**
   * @description: 组件挂载完毕：可以向服务器发送请求
   * @return {*}
   */
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    this.$store.dispatch("home/categoryList");
  },
  computed: {
    ...mapState({
      // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数将会立即执行一次
      // 注入一个参数state，其实即为大仓库的数据
      categoryList: (state) => state.home.categoryList,
    }),
  },
  methods: {
    /**
     * @description: 鼠标进入修改响应式数据currentIndex
     * @param {*} index 鼠标移上某一个一级分类的元素索引值
     * @return {*}
     */
    changeIndex(index) {
      this.currentIndex = index;
    },
    /**
     * @description: 一级分类鼠标移出事件的回调
     * @return {*}
     */
    leaveIndex() {
      // 直接调用上面的函数，传入null更改currentIndex
      this.changeIndex(null);
    },
  },
};
</script>
<style>
          .cur {
          background-color: skyblue;
        }
</style>
```

这里有一个问题：当我们需要在我们的鼠标放入“全部商品分类”的这边区域的时候，蓝色背景还不消失，这时候我们需要用到事件委派了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424194738978.png" alt="image-20230424194738978" style="zoom:50%;" />

由于红色导航栏和下面的蓝色区域是兄弟元素，我们需要把它们放在一起并且在它们俩的外面包上一层div，并且把鼠标离开的回调放在div上，实现事件委派

```vue
      <!-- 事件委派 鼠标离开h2和h3才会让currentIndex变回-1 -->
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        <div class="sort">
          <div class="all-sort-list2">
             <h3 @mouseenter="changeIndex(index)">
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
            ...
        </div>
      </div>
```

即可实现上述效果

# 16. 通过JS控制二三级分类显示与隐藏

项目的静态页面中，一开始我们是通过CSS样式`display:block|none`来控制显示与隐藏二三级商品分类的

​        <!-- 三级联动 -->
```vue
    <div class="sort">
      <div class="all-sort-list2">
        <div
          class="item"
          v-for="(c1, index) in categoryList"
          :key="c1.categoryId"
          :class="{ cur: currentIndex == index }"
        >
          <h3 @mouseenter="changeIndex(index)">
            <a href="">{{ c1.categoryName }}</a>
          </h3>
          <!-- 二级、三级分类 -->
          <div class="item-list clearfix">
           ...
          </div>
        </div>
      </div>
    </div>
```



```less
...

&hover {
	.item-list {
		display: block;
	}
}
```

我们可以删除掉这个less语句，通过`:style="JS表达式"`的方式，将样式交给Vue管理

```vue
          <!-- 二级、三级分类 -->
          <div class="item-list clearfix" :style="{display: currentIndex == index ? 'block' : 'none'}">
           ...
          </div>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425143056530.png" alt="image-20230425143056530" style="zoom:50%;" />

# 17. loadsh插件实现防抖和节流

在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率没有限制，就会加重浏览器的负担，导致用户体验非常的糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率的同时，又不影响实际效果

lodash官网：https://www.lodashjs.com/

**节流(throttle)：在规定的间隔事件范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发**，用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码

节流函数：https://www.lodashjs.com/docs/lodash.throttle

**防抖(debounce)：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次**，用户操作很频繁，但是只执行一次，减少业务负担。

防抖函数：https://www.lodashjs.com/docs/lodash.debounce

节流和防抖简述：https://www.jianshu.com/p/c8b86b09daf0

Vue-cli中已经有了lodash模块儿，该插件提供了防抖和节流的函数，我们可以直接引入到js进行调用，当然也可以自己写【学会闭包+延时器】

例如：我们将三级联动菜单组件中的changeIndex函数设置了节流，如果操作很频繁，我们则限制50ms执行一次，由于要用到这个函数，我们必须在写methods的时候需要采用es5的键值对形式，throttle的返回值就是一个函数，所以直接使用键值对赋值，原函数的参数直接当成throttle的参数

```js
import throttle from 'lodash/throttle'
  methods: {
    /**
     * @description: 鼠标进入修改响应式数据currentIndex 没有给这个函数做节流
     * @param {*} index 鼠标移上某一个一级分类的元素索引值
     * @return {*}
     */
    // changeIndex(index) {
    //   // 正常情况（用户慢慢地操作）：鼠标进入，每一个一级分类h3都会触发鼠标进入事件
    //   // 非正常情况（用户操作很快）：本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分的h3触发了
    //   // 就是因为用户行为过快，导致浏览器反应不过来。如果当前回调函数中有大量业务，就会出现卡顿
    //   this.currentIndex = index;
    // },
    
    // es6写法无法操作lodash的对象“_” 所以我们必须用es5的key:value写法
    /**
     * @description: 三级联动菜单中一级分类选中的节流
     * @param {Function} 需要做节流的函数
     * @param {[wait=0]} 在 wait 秒内最多执行 Function 函数
     * @return {*}
     */
    changeIndex: throttle(function(index){
      this.currentIndex = index
    }, 50),

    /**
     * @description: 一级分类鼠标移出事件的回调
     * @return {*}
     */
    leaveIndex() {
      // 直接调用上面的函数，传入null更改currentIndex
      this.changeIndex(null);
    },
  },
```

这样就可以节省性能提升用户体验

# 18. 编程式导航+事件委派实现路由跳转

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425191804385.png" alt="image-20230425191804385" style="zoom:50%;" />

如上图所示，我们页面中三级标签的列表非常多，每一个标签都是一个a标签，我们要实现通过点击a标签实现路由跳转

前面提到，我们实现路由跳转有两种方法：**声明式路由导航、编程式路由导航**

```markdown
对于声明式路由导航：我们有多少个a标签，就会生成多少个router-link标签，一个router-link标签我们可以把它当成组件，这样一千个a标签就会有一千多个router-link标签，我们在频繁操作的时候就会产生卡顿现象影响用户体验

对于编程式路由导航：我们是通过触发点击事件来实现的路由跳转。所以理论上有多少个a标签就会有多少个事件回调函数。虽然不会触发卡顿，但是也会影响性能
```

上面所说的方法无论采用哪一种，都会影响性能。于是我们提出一种：**编程式路由导航+事件委派**的方式来实现路由跳转。事件委派就是把子节点的触发事件都委托给父节点，这样只需要一个回调函数`goSearch`就能解决问题，谁需要这个事件的回调就给谁用

**然而使用事件委派就会产生新的问题：**

	* 如何确定我们点击的一定是a标签呢？如何保证我们只能通过点击a标签跳转呢？（因为只用事件委派，可以点击非a标签元素也实现跳转，这不符合我们的需求）
	* 如何获取子节点标签的商品名称和商品Id呢?（**我们是通过商品名称和商品Id进行页面跳转的**）

**解决办法：**

对于问题1：为三个等级的a标签添加自定义属性`data-categoryName`，用来绑定商品标签名称来标识a标签和其他标签

对于问题2：为三个等级的a标签分别添加自定义属性`data-category1Id`、`data-category2Id`、`data-category3Id`，来获取三个a标签的商品id，实现路由跳转

由于后端在传过来的数据中为每个a标签带了name和id，所以这几个自定义属性的值可以为对应的name和id

`/src/components/TypeNav/index.vue`

```vue
        <h2 class="all">全部商品分类</h2>
        <!-- 三级联动 -->
        <div class="sort">
          <!-- 事件委派 谁需要这个事件的回调就给谁用 -->
          <div class="all-sort-list2" @click="goSearch">
            <!-- 一级分类 -->
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
              :class="{ cur: currentIndex == index }"
            >
              <h3 @mouseenter="changeIndex(index)">
                <a
                  :data-categoryName="c1.categoryName"
                  :data-category1Id="c1.categoryId"
                  >{{ c1.categoryName }}</a
                >
              </h3>
              <!-- 二级、三级分类 -->
              <div
                class="item-list clearfix"
                :style="{ display: currentIndex == index ? 'block' : 'none' }"
              >
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a
                        :data-categoryName="c2.categoryName"
                        :data-category2Id="c2.categoryId"
                        >{{ c2.categoryName }}</a
                      >
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a
                          :data-categoryName="c3.categoryName"
                          :data-category3Id="c3.categoryId"
                          >{{ c3.categoryName }}</a
                        >
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>
```

**要注意的是，**e是事件对象，我们在函数定义的时候作为参数传入就可以了

```vue
//函数使用
<div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex">
//函数定义
goSearch(e){
      console.log(e.target)
    }

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/4406011f40ab4b4db06e32974408ec1e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_12,color_FFFFFF,t_70,g_se,x_16)

相应的`goSearch`回调函数：

```js
    /**
     * @description: 路由跳转到的Search组件的回调
     * @return {*}
     */
    goSearch(e) {
      // 最好的解决方案：编程式路由导航+事件委派
      // 利用事件委派存在的一些问题：1.点击的不一定是a标签 2.如何获取参数【1、2、3级分类的产品名字、id】
      // 我们需要点击a标签的时候才会进行路由跳转【怎么能确定点击的一定是a标签】
      // 即使我们能确定点击的是a标签，是如何区分一级、二级、三级的a标签呢
      // 第一个问题：把子节点当中的a标签，加上我们自定义的属性data-categoryName，其余子节点是没有的
      // ES6写法：解构
      // html中会把大写转为小写
      let { categoryname, category1id, category2id, category3id } =
        e.target.dataset;
      //categoryname存在，表示为a标签
      if (categoryname) {
        // 整理路由跳转的参数
        let location = { name: "Search" }; // 路由跳转的name
        let query = { categoryName: categoryname }; // 路由的query参数
        if (category1id) {
          // category1id一级a标签
          query.category1Id = category1id;
        } else if (category2id) {
          // category2id二级a标签
          query.category2Id = category2id;
        } else {
          // category3id三级a标签
          query.category3Id = category3id;
        }
        // 整理完参数，将两个对象合二为一
        location.query = query;
        // 这样就可以携带query参数进行路由跳转操作
        this.$router.push(location);
      }
    },
```

这样可以在节省性能的同时只通过a标签跳转并且传递了query参数

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425194040938.png" alt="image-20230425194040938" style="zoom:50%;" />

# 19. Search模块中商品分类与过渡动画

我们在home页面中点击每一个A标签都会携带query参数跳转到search页面，这个时候全局组件TypeNav就需要默认隐藏，并且我们需要在鼠标放到红色框框的时候用动画过渡出一级菜单

首先我们实现切到非home页面来隐藏一二三级菜单：

首先我们需要在组件里存一个布尔值来标识是否需要显示

`src/components/TypeNav/index.vue`

这里把之前写好的更改index的回调和隐藏分类菜单的回调合二为一

```js
<!-- 三级联动 -->
<!-- 过渡动画 -->
<div class="sort" v-show="isShow">
  ......
data() {
    return {
      // 存储用户鼠标移上哪一个一级分类
      currentIndex: null,
      // 存储是否显示一二三级菜单的标识
      isShow: true,
    };
  },
```

相应的两个进入和离开方法：

```vue
      <!-- 事件委派 鼠标离开h2和h3才会让currentIndex变回-1 以及离开或进入标题时h1的显示与隐藏 -->
      <div @mouseleave="leaveShow" @mouseenter="enterShow">
   		...
      <script>
        	methods: {
                /**
     						* @description: 当鼠标移入的时候，让商品分类列表进行展示
     						* @return {*}
     						*/
          enterShow() {
            this.isShow = true;
          },
        },
              /**
             * @description: 一级分类鼠标移出事件的回调 在Search组件有额外效果：移出不显示
             * @return {*}
             */
            leaveShow() {
              // 直接调用上面的函数，传入null更改currentIndex
              this.changeIndex(null);
              // 判断如果是非Home组件的时候才会执行
              if (this.$route.path != "/home") {
                this.isShow = false;
              }
            },
      }
      </script>
```

至此 我们就实现了切换页面自动隐藏分类菜单了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230426185158279.png" alt="image-20230426185158279" style="zoom:50%;" />

接下来我们着手实现菜单的过渡动画

思路是使用我们Vue基础中讲过的安装第三方库`animate.css`并配合transition标签来使用

`scr/components/TypeNav.index.vue`

```vue
        <h2 class="all">全部商品分类</h2>
        <!-- 三级联动 -->
        <!-- 过渡动画 -->
        <transition
          name="animate__animated animate__bounce"
          enter-active-class="animate__fadeIn"
          leave-active-class="animate__fadeOut"
        >
          <div class="sort" v-show="isShow">
            <!-- 事件委派 谁需要这个事件的回调就给谁用 -->
            <div class="all-sort-list2" @click="goSearch">
              <!-- 一级分类 -->
              ...
                </div>
              </div>
            </div>
          </div>
        </transition>

...
import "animate.css";
```

在animate.css的文档中挑选好效果就可以实现需要的过渡效果了，我们这里选的是透明渐变

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230426185530521.png" alt="image-20230426185530521" style="zoom:50%;" />

# 20. Vue中路由销毁问题

首先我们要知道的一点：**Vue在路由切换的时候回销毁旧路由**

我们在三级列表的全局组件TypeNav中的mounted进行了请求一次商品分类列表数据

由于**Vue在路由切换的时候会销毁旧路由**，当我们再次使用一次三级列表组件的时候，由于组件的重新挂载，则会再发一次请求

如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea8ece30280d452b920c25ecbf1ed211.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

由于服务器返回的信息都是一样的，处于性能考虑，我们只希望这个数据只请求一次，所以我们把请求语句移动到了`App.vue`的mounted中（根组件App.vue的mounted只会执行一次）

**注意**：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性，main.js身上的this为undefined

`src/App.vue`

```vue
<script>
import Header from "./components/Header";
import Footer from "./components/Footer";
export default {
  name: "App",
  components: {
    Header,
    Footer,
  },
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    // 把在TypeNav组件发的请求放到了全局组件App中，代表了只会发送一次，有利于性能节省
    this.$store.dispatch("home/categoryList");
  },
};
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230426201709074.png" alt="image-20230426201709074" style="zoom:50%;" />

# 21. 同时携带query和params参数

我们开发的项目目前位置，跳转到Search组件有两个方式：

	* 通过点击TypeNav组件中的商品分类菜单跳转
	* 通过点击Header组件中的搜索框实现跳转

当用户同时用了以上两种方式进行路由跳转到Search组件时，由于第一种方法传递的是query参数，第二种方法传递的是params参数，如果我们不判断的话，则很有可能造成另一种参数丢失

​	所以我们必须在每个路由跳转之前判断路径里面是否带有另一种参数

传query参数的同时判断是否有params参数：

`src/components/TypeNav/index.vue`

```js
...
    goSearch(e) {
      let { categoryname, category1id, category2id, category3id } =
        e.target.dataset;
      //categoryname存在，表示为a标签
      if (categoryname) {
        // 整理路由跳转的参数
        let location = { name: "Search" }; // 路由跳转的name
        let query = { categoryName: categoryname }; // 路由的query参数
				...
        // 判断：如果路由跳转带有了params参数，我们要捎带传递过去
        if (this.$route.params) {
          location.params = this.$route.params;
          // 整理完参数，将两个对象合二为一
          location.query = query;
          // 这样就可以携带query参数进行路由跳转操作
          this.$router.push(location);
        }
      }
    },
```

对应的，在传params参数的同时判断是否有query参数：

`src/components/Header/index.vue`

```js
...
    goSearch() {
      // 路由传递参数：
      // 第一种：字符串形式
      // this.$router.push('/search/' + this.keyWord + '?k=' + this.keyWord.toUpperCase())
      // 第二种：模板字符串
      // this.$router.push(`/search/${this.keyWord}?k=${this.keyWord.toUpperCase()}`)
      // 第三种：对象写法
      // 如果有query参数 则也带过去
      if (this.$route.query) {
        let location = {
          name: "Search",
          params: {
            keyWord: this.keyWord || undefined,
          },
        };
        location.query = this.$route.query;
        this.$router.push(location);
      }
    },
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230427170423073.png" alt="image-20230427170423073" style="zoom:50%;" />

这样既可以达成同时传参的目标

# 22. mock的使用

mock通常用来生成随机数据、拦截ajax请求，返回我们自定义的数据用于测试前端接口

我们将不同的数据封装为不同的json文件

这里我们为home页面上的ListContainer、Floor组件准备了数据

`/src/mock/banner.json`

```json
[
  {
    "id": "1",
    "imgUrl": "/images/banner1.jpg"
  },
  {
    "id": "2",
    "imgUrl": "/images/banner2.jpg"
  },
  {
    "id": "3",
    "imgUrl": "/images/banner3.jpg"
  },
  {
    "id": "4",
    "imgUrl": "/images/banner4.jpg"
  }
]

```

`src/mock/floor.json`

```json
[
  {
    "id": "001",
    "name": "家用电器",
    "keywords": [
      "节能补贴",
      "4K电视",
      "空气净化器",
      "IH电饭煲",
      "滚筒洗衣机",
      "电热水器"
    ],
    "imgUrl": "/images/floor-1-1.png",
    "navList": [
      {
        "url": "#",
        "text": "热门"
      },
      {
        "url": "#",
        "text": "大家电"
      },
      {
        "url": "#",
        "text": "生活电器"
      },
      {
        "url": "#",
        "text": "厨房电器"
      },
      {
        "url": "#",
        "text": "应季电器"
      },
      {
        "url": "#",
        "text": "空气/净水"
      },
      {
        "url": "#",
        "text": "高端电器"
      }
    ],
    "carouselList": [
      {
        "id": "0011",
        "imgUrl": "/images/floor-1-b01.png"
      },
      {
        "id": "0012",
        "imgUrl": "/images/floor-1-b02.png"
      },
      {
        "id": "0013",
        "imgUrl": "/images/floor-1-b03.png"
      }
    ],
    "recommendList": [
      "/images/floor-1-2.png",
      "/images/floor-1-3.png",
      "/images/floor-1-5.png",
      "/images/floor-1-6.png"
    ],
    "bigImg": "/images/floor-1-4.png"
  },
  {
    "id": "002",
    "name": "手机通讯",
    "keywords": [
      "节能补贴2",
      "4K电视2",
      "空气净化器2",
      "IH电饭煲2",
      "滚筒洗衣机2",
      "电热水器2"
    ],
    "imgUrl": "/images/floor-1-1.png",
    "navList": [
      {
        "url": "#",
        "text": "热门2"
      },
      {
        "url": "#",
        "text": "大家电2"
      },
      {
        "url": "#",
        "text": "生活电器2"
      },
      {
        "url": "#",
        "text": "厨房电器2"
      },
      {
        "url": "#",
        "text": "应季电器2"
      },
      {
        "url": "#",
        "text": "空气/净水2"
      },
      {
        "url": "#",
        "text": "高端电器2"
      }
    ],
    "carouselList": [
      {
        "id": "0011",
        "imgUrl": "/images/floor-1-b01.png"
      },
      {
        "id": "0012",
        "imgUrl": "/images/floor-1-b02.png"
      },
      {
        "id": "0013",
        "imgUrl": "/images/floor-1-b03.png"
      }
    ],
    "recommendList": [
      "/images/floor-1-2.png",
      "/images/floor-1-3.png",
      "/images/floor-1-5.png",
      "/images/floor-1-6.png"
    ],
    "bigImg": "/images/floor-1-4.png"
  }
]
```

安装mock

```shell
npm i mockjs
```

在文件夹里创建一个mock服务器

`src/mock/mockServer.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-27 17:52:55
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-27 18:08:59
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/mock/mockSever.js
 * @Description: mock模拟数据服务器
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */

// 先引入mockjs模块
import Mock from 'mockjs'
// 把JSON数据格式引入进来[JSON数据格式根本没有对外暴露，但是可以引入]
// webpack默认对外暴露的资源：图片、JSON数据格式
import banner from './banner.json'
import floor from './floor.json'

/**
 * @description: 模拟首页广告轮播图数据
 * @param {String} url 参数请求的地址
 * @param {Object} 请求的数据
 * @return {*}
 */
Mock.mock('/mock/banner', {code: 200, data: banner})

/**
 * @description: 模拟首页楼层数据
 * @param {String} url 参数请求的地址
 * @param {Object} 请求的数据
 * @return {*}
 */
Mock.mock('/mock/floor', {code: 200, data: floor})
```

既然是一个服务器，向外发送了请求，则需要在api文件夹里专门管理这些请求

这里我们与真实发送给服务器的文件相仿，创建了一个文件专门来处理和匹配发送给mock服务器的请求（和发送真实服务器的request.js文件相仿）

其实相对于request.js，就改了目标url

`/src/mockAjax.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-27 18:25:07
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-27 18:26:17
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/api/mockAjax.js
 * @Description: 使用mock发送模拟数据
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */
// 对于axios进行二次封装
import axios from "axios";
// 引入进度条
import nProgress from "nprogress";
// 引入进度条样式
import "nprogress/nprogress.css"
// start：进度条开始 done：进度条结束

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/mock
    baseURL: '/mock',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
/**
 * @description: 请求拦截器：在发请求之前，它可以检测到，并做一些事情
 * @return {Object} 
 */
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token

    // 开启进度条
    nProgress.start()

    return config
})
/**
 * @description: 响应拦截器
 * @return {Object}
 */
requests.interceptors.response.use((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    // 响应成功，关闭进度条
    nProgress.done()
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器响应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

配置完这些后，我们可以在相应的组件中给mock服务器发送请求

`src/pages/Home/ListContainer/index.vue`

```js
  mounted() {
    this.$store.dispatch("home/getBannerList");
  },
```

既然在actions里我们发送了请求，根据项目的要求，我们得把这个请求函数放在api里统一管理

`src/api/index.js`

```js
import requests from "./request";
import mockRequests from './mockAjax'

/**
 * @description: 三级联动菜单的接口 是get请求 无参数
 * @url /api/product/getBaseCategoryList 
 * @return {Object: Promise}
 */
export const reqGetCategoryList = () => {
    // 发请求：axios发请求返回的结果是Promise对象
    // 必须把服务器响应的数据返回供其他组件和模块使用
    return requests({
        method: 'GET',
        url: '/product/getBaseCategoryList', 
    })
}

/**
 * @description: 轮播图的接口 是get请求 无参数
 * @url /mock/banner
 * @return {Object: Promise}
 */
export const reqGetBannerList = () => {
    return mockRequests({
        method: 'GET',
        url: '/banner'
    })
}
```

actions得在store里有相应的mutations以及数据流与其对应：

`/src/store/home/index.js`

```js
import { reqGetCategoryList, reqGetBannerList } from "@/api";
// 仓库存储数据的地方
const state = {
  // state中数据的默认初始值别瞎写，根据接口的返回值来决定初始值
  categoryList: [],
  bannerList: [],
};
// 修改state的唯一手段
const mutations = {
  //
  UPDATECATEGORYLIST(state, categoryList) {
    state.categoryList = categoryList;
  },
  UPDATEBANNERLIST(state, bannerList) {
    state.bannerList = bannerList;
  },
};
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {
...
  /**
   * @description: 获取首页轮播图的数据
   * @param {*} context 上下文
   * @return {*}
   */
  getBannerList(context) {
    reqGetBannerList().then(
      (res) => {
        if (res.code === 200) {
          context.commit("UPDATEBANNERLIST", res.data);
        }
      },
      (error) => {
        console.log(error);
      }
    );
  },
};
```

然后再在相应组件中读取通过mock服务器返回并存放在state中数据

`src/pages/Home/ListContainer/index.vue`

```js
  ...
  computed: {
    ...mapState({
      // bannerList: (state) => {
      //   return state.home.bannerList
      // }
      bannerList: state => state.home.bannerList
    })
  },
  ...
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230427204551107.png" alt="image-20230427204551107" style="zoom:50%;" />

只要是公共数据都会放在store中，之后的实现步骤就是上面的固定步骤。

# 23. swiper插件实现轮播图

Swiper官网：https://www.swiper.com.cn/

官网中给出了代码案例

使用小结：

```
1. 安装swiper
2. 在需要使用轮播图的组件内导入swiper和它的css样式
3. 在组件中穿件swiper所需要的dom标签（html代码，参考官网使用说明）
4. 创建swiper实例
```

在通过举例复习swiper的使用后，我们接下来要考虑的是什么时候加载这个swiper，我们第一时间想到的是在`mounted`中创建这个实例，但是会出现无法加载轮播图片的问题

`src/pages/Home/ListContainer/index.vue`

```vue
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">
          <div class="swiper-wrapper">
            <div
              class="swiper-slide"
              v-for="(carousel, index) in bannerList"
              :key="carousel.id"
            >
              <img :src="carousel.imgUrl" />
            </div>
          </div>
          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
```

```js
mounted() {
	//请求数据
    this.$store.dispatch("getBannerList")
    console.log('初始化swiper实例')
    // ...相关的swiper轮播图操作
  },

```

结果发现无法使用轮播图，bannerList这个数据是通过Vuex拿来的，我们在相应的actions以及mutations做了调试打印来查看问题

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230430184106038.png" alt="image-20230430184106038" style="zoom:50%;" />



> 我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。

* 解决方法一：等我们数据请求完毕之后再创建swiper实例，加上一个时间延迟再创建swiper实例，将上面的代码改为：

```js
  mounted() {
    console.log('轮播图的mounted');
    this.$store.dispatch("home/getBannerList");
    // 在new Swiper实例之前，页面中的结构必须得先有 现在如果把new Swiper实例放在这里则不行
    // 因为dispatch当中涉及到异步语句，导致v-for遍历的时候结构还不完全
    setTimeout(() => {
      console.log('初始化swiper实例');
    }, 2000);
  },
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230430184733502.png" alt="image-20230430184733502" style="zoom:50%;" />

* 解决方法二：我们可以使用watch监听来自于仓库的bannerList轮播图列表属性，因为bannerList初始值为空，当它有数据的时候，我们就可以创建swiper对象

```js
  watch: {
    // 监听bannerList数据的变化
    bannerList: {
      /**
       * @description: 通过watch监听bannerList属性的属性值的变化，如果执行handler方法，代表组件实例身上这个属性的属性值已经有了变化
       * @param {*} newVal
       * @param {*} oldVal
       * @return {*}
       */
      handler(newVal, oldVal) {
					console.log('初始化Swiper实例')
        ...
        });
      },
    },
  },
```

> 这里的控制台和上图是一样的，但是还是无法实现轮播图 原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片（因为swiper对象生效的前提是html即dom结构已经渲染好了）

* **完美解决方案**：使用watch+[this.$nextTick()](https://cn.vuejs.org/v2/api/#vm-nextTick)
  官方介绍：this. $nextTick它会将回调延迟到下次 DOM **更新循环之后执行**（循环就是这里的v-for）。
  **个人理解**：无非是等我们页面中的结构都有了再去执行回调函数

完整代码：

`src/pages/Home/ListContainer/index.vue`

```vue
<template>
  <!--列表-->
  <div class="list-container">
    <div class="sortList clearfix">
      <div class="center">
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">
          <div class="swiper-wrapper">
            <div
              class="swiper-slide"
              v-for="(carousel, index) in bannerList"
              :key="carousel.id"
            >
              <img :src="carousel.imgUrl" />
            </div>
          </div>
          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
      <div class="right">
        <div class="news">
          <h4>
            <em class="fl">尚品汇快报</em>
            <span class="fr tip">更多 ></span>
          </h4>
          <div class="clearix"></div>
          <ul class="news-list unstyled">
            <li><span class="bold">[特惠]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[公告]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[特惠]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[公告]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[特惠]</span>备战开学季 全民半价购数码</li>
          </ul>
        </div>
        <ul class="lifeservices">
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">话费</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">机票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">电影票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">游戏</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">彩票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">加油站</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">酒店</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">火车票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">众筹</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">理财</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">礼品卡</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">白条</span>
          </li>
        </ul>
        <div class="ads">
          <img src="./images/ad1.png" />
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapState } from "vuex";
import Swiper from "swiper";
export default {
  name: "ListContainer",
  /**
   * @description: 派发actions，通过Vuex发起ajax请求，将数据存储在仓库中
   * @return {*}
   */
  mounted() {
    this.$store.dispatch("home/getBannerList");
    // 在new Swiper实例之前，页面中的结构必须得先有 现在如果把new Swiper实例放在这里则不行
    // 因为dispatch当中涉及到异步语句，导致v-for遍历的时候结构还不完全
  },
  computed: {
    ...mapState({
      // bannerList: (state) => {
      //   return state.home.bannerList
      // }
      bannerList: (state) => state.home.bannerList,
    }),
  },
  watch: {
    // 监听bannerList数据的变化
    bannerList: {
      /**
       * @description: 通过watch监听bannerList属性的属性值的变化，如果执行handler方法，代表组件实例身上这个属性的属性值已经有了变化
       * @param {*} newVal
       * @param {*} oldVal
       * @return {*}
       */
      handler(newVal, oldVal) {
        // 当前这个函数执行，只能保证bannerList数据已经有了，但是你没办法保证v-for已经执行结束了
        // v-for执行完毕才会有结构
        this.$nextTick(() => {
          // 当你真行这个回调的时候，保证服务器数据回来了，v-for执行完毕了【轮播图的解构一定会有的】
          var mySwiper = new Swiper(".swiper-container", {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
              clickable: true,
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
};
</script>
```

>  注意：之前我们在学习watch时，一般都是监听的定义在data中的属性，但是我们这里是监听的computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。

另外还有一个知识点提到：

在创建swiper对象时，我们会传递一个参数用于获取展示轮播图的DOM元素，官网直接通过class（而且这个class不能修改，是swiper的css文件自带的）获取。但是这样有缺点：当页面中有多个轮播图时，因为它们使用了相同的class修饰的DOM，就会出现所有的swiper使用同样的数据，这肯定不是我们希望看到的。
解决方法：在轮播图最外层DOM中添加ref属性

```html
<div class="swiper-container" id="mySwiper" ref="cur">
```

通过ref属性值获取DOM

```js
let mySwiper = new Swiper(this.$refs.cur,{...})
```

```vue
 <!--banner轮播-->
        <div class="swiper-container" id="mySwiper" ref="cur">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
<script>
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
</script>

```

# 24. props父子组件通信

原理：父组件设置一个属性绑定要传递的数据

子组件通过props接受该属性值

父组件：Home

`src/pages/Home/index.vue`

```vue
<template>
<div>
//...省略
<!--  父组件通过自定义属性list给子组件传递数据-->
  <Floor v-for="item in floorList"  :key="item.id" :list="item"/>
<!--  商标-->
 
</div>
</template>


```

子组件Floor

`src/pages/Home/Floor/index.vue`

```vue
<template>
  <!--楼层-->
  <div class="floor">
    //...省略
  </div>
</template>

<script>
export default {
  name: "floor",
//子组件通过props属性接受父组件传递的数据
  props:['list']
}
</script>
```

第一张图是home组件的信息，我们的目的是将floorList中的数据分发给Floor组件

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f43c0c951b446ef92de7c00e37b05ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/d1609e96dd89467c805ddef0bedf171a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

其实自己想的是使用全局事件总线解决，奈何总是在Floor组件接收到数据，无法把两个数据分配给两个不同的组件 所以就没有写下去了 但是学到了很多 

`src/pages/Home/index.vue`

```js
  methods: {
    // 自定义事件
    sendFloorListData() {
      this.$bus.$emit("getFloorListData", this.floorList);
      console.log("已发送");
    },
  },
  /**
   * @description: 视频里面使用的是props传参，我这里使用了全局事件总线，可能和ListContainer里面的v-for循环一样会有异步问题，这里仍然使用watch+nextTick来解决这个问题
   * @return {*}
   */
  watch: {
    floorList: {
      handler() {
        this.$nextTick(() => {
          this.sendFloorListData();
        });
      },
    },
  },
```

`src/pages/Home/Floor/index.vue`

```js
import Swiper from "swiper";
export default {
  name: "Floor",
  data() {
    return {
      dataList: [],
    };
  },
  mounted() {
    /**
     * @description: 执行自定义事件的回调，并接收传过来的数据
     * @return {*}
     */
    this.$bus.$on("getFloorListData", (data) => {
      this.dataList = data;
    });

    // 前面在ListContainer的mounted中使用swiper的时候是不可以的 为什么现在就可以了？
    // 因为在前面书写轮播图的时候，是在当前组件的内部发请求，动态渲染结构【前台至少服务器数据需要回来】，因此之前的写法是不行的
    // 现在的这种写法可以 是因为请求是父组件发的
    var mySwiper = new Swiper(".swiper-container", {
      loop: true, // 循环模式选项

      // 如果需要分页器
      pagination: {
        el: ".swiper-pagination",
        clickable: true,
      },

      // 如果需要前进后退按钮
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
    });
  },
};
```

这里已经在dataList中拿到了数据 但是不知道怎么分配 以后可以去问一问
