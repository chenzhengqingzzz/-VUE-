# 尚硅谷Vue项目实战——尚品汇

**GitHub代码地址**

https://github.com/chenzhengqingzzz/shangpinhuishop

# **前端Vue核心**

用Vue开发一个前端模块可以概括为以下几个步骤：

	1. 写静态页面、拆分静态组件
	1. 发请求（API）
	1. vuex(actions/mutations/state三连操作)
	1. 组件获取仓库数据，动态展示

# 1. vue文件目录分析

**public文件夹：**静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中

**public/index.html**是一个模板文件，作用是生成项目的入口文件，webpack打包的js，css，也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html

**src文件夹（程序员代码文件夹）**

```
assets： 存放公用的静态资源（一般放置多个组件公用的静态资源）需要注意：放在assets文件夹里面的静态资源在webpack打包的时候会被当做模块打包到JS文件里面
components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中
App.vue： 唯一的根组件
main.js： 程序入口文件，最先执行的文件
babel.config.js: 配置文件（babel相关）
package.json: 项目的详细信息记录
package-lock.json: 缓存性文件（各种包的来源）
```

# 2. 项目配置

## 2.1 项目运行，浏览器自动打开

`src/package.json`

```js
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
```

## 2.2 关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）

* src根目录创建vue.config.js进行配置

`src/vue.config.js`

```js
module.exports = {
  //关闭eslint
  lintOnSave: false
  }
```

## 2.3 src文件夹简写方法，配置别名

​	`jsconfig.json`配置别名@提示【@代表的是src文件夹，这样将来文件过多，找的时候方便很多，exclude表示不可以使用该别名的文件】

```js
 {
    "compilerOptions": {
        "baseUrl": "./",
            "paths": {
            "@/*": [
                "src/*"
            ]
        }
    },

    "exclude": [
        "node_modules",
        "dist"
    ]
 }
```

# 3. 项目路由的分析

vue-router

前端所谓路由：ket-value键值对

key：URL（地址栏中的路径）

value：相应的路由组件

注意：项目的上中下结构

路由组件：

Home首页路由组件、Search路由组件、Login登录路由组件、Register注册路由组件

非路由组件：

Header【首页、搜索页】

Footer【在首页、搜索页】，但是在登录、注册界面没有

# 4. 组件页面样式

组件页面的样式使用的是less样式，浏览器不识别该样式，需要下载相关依赖

```shell
npm i --save less less-loader
```

如果想让组件识别less样式，则需要在组件中设置

```vue
<style scoped lang="less">
```

`src/components/Header/index.vue`

```vue
<template>
  <!-- 头部 -->
  <header class="header">
    <!-- 头部的第一行 -->
    <div class="top">
      <div class="container">
        <div class="loginList">
          <p>尚品汇欢迎您！</p>
          <p>
            <span>请</span>
            <!-- 只是跳过去，没有别的业务，可以用声明式导航 -->
            <router-link to="/login">登录</router-link>
            <router-link class="register" to="/register">免费注册</router-link>
          </p>
        </div>
        <div class="typeList">
          <a href="###">我的订单</a>
          <a href="###">我的购物车</a>
          <a href="###">我的尚品汇</a>
          <a href="###">尚品汇会员</a>
          <a href="###">企业采购</a>
          <a href="###">关注尚品汇</a>
          <a href="###">合作招商</a>
          <a href="###">商家后台</a>
        </div>
      </div>
    </div>
    <!--头部第二行 搜索区域-->
    <div class="bottom">
      <h1 class="logoArea">
        <router-link class="logo" title="尚品汇" to="/home">
          <img src="./images/logo.png" alt="" />
        </router-link>
      </h1>
      <div class="searchArea">
        <form action="###" class="searchForm">
          <input
            type="text"
            id="autocomplete"
            class="input-error input-xxlarge"
          />
          <button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
            搜索
          </button>
        </form>
      </div>
    </div>
  </header>
</template>

<script>
export default {
  name: "Header",
  methods: {
    // 搜索按钮的回调函数，需要向Search路由进行跳转
    goSearch(){
      this.$router.push('/search')
    }
  },
};
</script>

<style scoped lang="less">
.header {
  & > .top {
    background-color: #eaeaea;
    height: 30px;
    line-height: 30px;

    .container {
      width: 1200px;
      margin: 0 auto;
      overflow: hidden;

      .loginList {
        float: left;

        p {
          float: left;
          margin-right: 10px;

          .register {
            border-left: 1px solid #b3aeae;
            padding: 0 5px;
            margin-left: 5px;
          }
        }
      }

      .typeList {
        float: right;

        a {
          padding: 0 10px;

          & + a {
            border-left: 1px solid #b3aeae;
          }
        }
      }
    }
  }

  & > .bottom {
    width: 1200px;
    margin: 0 auto;
    overflow: hidden;

    .logoArea {
      float: left;

      .logo {
        img {
          width: 175px;
          margin: 25px 45px;
        }
      }
    }

    .searchArea {
      float: right;
      margin-top: 35px;

      .searchForm {
        overflow: hidden;

        input {
          box-sizing: border-box;
          width: 490px;
          height: 32px;
          padding: 0px 4px;
          border: 2px solid #ea4a36;
          float: left;

          &:focus {
            outline: none;
          }
        }

        button {
          height: 32px;
          width: 68px;
          background-color: #ea4a36;
          border: none;
          color: #fff;
          float: left;
          cursor: pointer;

          &:focus {
            outline: none;
          }
        }
      }
    }
  }
}
</style>

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210225240.png" alt="image-20230420210225240" style="zoom:50%;" />

`src/components/Footer/index.vue`

```vue
<template>
  <!-- 底部 -->
  <div class="footer">
    <div class="footer-container">
      <div class="footerList">
        <div class="footerItem">
          <h4>购物指南</h4>
          <ul class="footerItemCon">
            <li>购物流程</li>
            <li>会员介绍</li>
            <li>生活旅行/团购</li>
            <li>常见问题</li>
            <li>购物指南</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>配送方式</h4>
          <ul class="footerItemCon">
            <li>上门自提</li>
            <li>211限时达</li>
            <li>配送服务查询</li>
            <li>配送费收取标准</li>
            <li>海外配送</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>支付方式</h4>
          <ul class="footerItemCon">
            <li>货到付款</li>
            <li>在线支付</li>
            <li>分期付款</li>
            <li>邮局汇款</li>
            <li>公司转账</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>售后服务</h4>
          <ul class="footerItemCon">
            <li>售后政策</li>
            <li>价格保护</li>
            <li>退款说明</li>
            <li>返修/退换货</li>
            <li>取消订单</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>特色服务</h4>
          <ul class="footerItemCon">
            <li>夺宝岛</li>
            <li>DIY装机</li>
            <li>延保服务</li>
            <li>尚品汇E卡</li>
            <li>尚品汇通信</li>
          </ul>
        </div>
        <div class="footerItem">
          <h4>帮助中心</h4>
          <img src="./images/wx_cz.jpg" />
        </div>
      </div>
      <div class="copyright">
        <ul class="helpLink">
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            联系我们
            <span class="space"></span>
          </li>
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            商家入驻
            <span class="space"></span>
          </li>
          <li>
            营销中心
            <span class="space"></span>
          </li>
          <li>
            友情链接
            <span class="space"></span>
          </li>
          <li>
            关于我们
            <span class="space"></span>
          </li>
          <li>
            营销中心
            <span class="space"></span>
          </li>
          <li>
            友情链接
            <span class="space"></span>
          </li>
          <li>关于我们</li>
        </ul>
        <p>地址：北京市昌平区宏福科技园综合楼6层</p>
        <p>京ICP备19006430号</p>
      </div>
    </div>
  </div>
</template>

<script>
export default {
  name: "Footer",
};
</script>

<style scoped lang="less" >
.footer {
  background-color: #eaeaea;

  .footer-container {
    width: 1200px;
    margin: 0 auto;
    padding: 0 15px;

    .footerList {
      padding: 20px;
      border-bottom: 1px solid #e4e1e1;
      border-top: 1px solid #e4e1e1;
      overflow: hidden;
      padding-left: 40px;

      .footerItem {
        width: 16.6666667%;
        float: left;

        h4 {
          font-size: 14px;
        }

        .footerItemCon {
          li {
            line-height: 18px;
          }
        }

        &:last-child img {
          width: 121px;
        }
      }
    }

    .copyright {
      padding: 20px;

      .helpLink {
        text-align: center;

        li {
          display: inline;

          .space {
            border-left: 1px solid #666;
            width: 1px;
            height: 13px;
            background: #666;
            margin: 8px 10px;
          }
        }
      }

      p {
        margin: 10px 0;
        text-align: center;
      }
    }
  }
}
</style>
```

![image-20230420210309954](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210309954.png)

# 4. 清除vue页面默认的样式

引入结构和样式后，会发现我们的样式有些许错位，则需要按照项目的要求清除默认样式

vue是单页面开发，我们只需要修改public下的index.html文件

```html
<link rel="stylesheet" href="reset.css">
```

`app/public/reset.css`

```css
/* @import "./iconfont.css"; */
 
/* 清除内外边距 */
body, h1, h2, h3, h4, h5, h6, hr, p, blockquote,
dl, dt, dd, ul, ol, li,
pre,
fieldset, lengend, button, input, textarea,
th, td {
    margin: 0;
    padding: 0;
}

/* 设置默认字体 */
body,
button, input, select, textarea { /* for ie */
    /*font: 12px/1 Tahoma, Helvetica, Arial, "宋体", sans-serif;*/
    font: 12px/1.3 "Microsoft YaHei",Tahoma, Helvetica, Arial, "\5b8b\4f53", sans-serif; /* 用 ascii 字符表示，使得在任何编码下都无问题 */
    color: #333;
}


h1 { font-size: 18px; /* 18px / 12px = 1.5 */ }
h2 { font-size: 16px; }
h3 { font-size: 14px; }
h4, h5, h6 { font-size: 100%; }

address, cite, dfn, em, var, i{ font-style: normal; } /* 将斜体扶正 */
b, strong{ font-weight: normal; } /* 将粗体扶细 */
code, kbd, pre, samp, tt { font-family: "Courier New", Courier, monospace; } /* 统一等宽字体 */
small { font-size: 12px; } /* 小于 12px 的中文很难阅读，让 small 正常化 */

/* 重置列表元素 */
ul, ol { list-style: none; }

/* 重置文本格式元素 */
a { text-decoration: none; color: #666;}


/* 重置表单元素 */
legend { color: #000; } /* for ie6 */
fieldset, img { border: none; }
button, input, select, textarea {
    font-size: 100%; /* 使得表单元素在 ie 下能继承字体大小 */
}

/* 重置表格元素 */
table {
    border-collapse: collapse;
    border-spacing: 0;
}

/* 重置 hr */
hr {
    border: none;
    height: 1px;
}
.clearFix::after{
	content:"";
	display: block;
	clear:both;
}
/* 让非ie浏览器默认也显示垂直滚动条，防止因滚动条引起的闪烁 */
html { overflow-y: scroll; }

a:link:hover{
    color : rgb(79, 76, 212) !important;
    text-decoration: underline;
}

/* 清除浮动 */
.clearfix::after {
    display: block;
    height: 0;
    content: "";
    clear: both;
    visibility: hidden;
}
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210344299.png" alt="image-20230420210344299" style="zoom:50%;" />

# 5. pages文件夹

创建pages文件夹，并创建路由组件

`src/pages/Home/index.vue`

`src/pages/Login/index.vue`

`src/pages/Register/index.vue`

`src/pages/Search/index.vue`

## 5.1 创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册

`src/router/index.js`

```js
// 路由器，配置路由器的地方
import Vue from "vue";
import VueRouter from "vue-router";
// 使用插件
Vue.use(VueRouter)

// 引入路由组件
import Home from '../pages/Home'
import Search from '@/pages/Search'
import Login from '@/pages/Login'
import Register from '@/pages/Register'
// 配置路由
export default new VueRouter({
    routes: [
        {
            path: '/home',
            component: Home,
        },
        {
            path: '/search',
            component: Search,
        },
        {
            path: '/login',
            component: Login,
        },
        {
            path: '/register',
            component: Register,
        },
        // 重定向，在项目跑起来的时候，访问"/"，立马定向到首页
        {
            path: '*',
            redirect: '/home'
        }
    ]
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210416944.png" alt="image-20230420210416944" style="zoom:50%;" />

## 5.2 总结

路由组件和非路由组件的区别：

* 非路由组件放在components文件夹中，路由组件放在pages或view中
* 非路由组件通过标签使用，路由组件通过路由使用
* 在main.js中注册完路由，所有的路由和非路由组件身上都会拥有`$router`和`$route`属性
* `$router`：一般进行编程式路由导航进行路由跳转
* `$route`：一般获取路由信息（name path params等）

## 5.3 路由跳转方式

* 声明式路由导航：`router-link`标签，可以吧`router-link`理解为一个a标签，它也可以加class修饰

`src/components/Header/index.vue`

```vue
<!-- 只是跳过去，没有别的业务，可以用声明式导航 -->
<router-link to="/login">登录</router-link>
<router-link class="register" to="/register">免费注册</router-link>
```

* 编程式路由导航：声明式路由导航能做的编程式路由导航都能做，而且还可以处理一些业务

`src/components/Header/index.vue`

```vue
<button class="sui-btn btn-xlarge btn-danger" type="button" @click="goSearch">
    搜索
</button>
<script>
  methods: {
    // 搜索按钮的回调函数，需要向Search路由进行跳转
    goSearch(){
      this.$router.push('/search')
    }
  },
</script>
```

# 6. Footer组件的显示与隐藏

* Footer组件在登录、注册页面是不存在的，所以要隐藏，用`v-if`或`v-show`
* 这里使用`v-show`，因为`v-if`会频繁操作DOM元素消耗性能，`v-show`只是通过样式将元素显示或隐藏
* 配置路由的时候，可以给路由配置元信息`meta`
* 在路由的元信息中定义`isShowFooter`属性，用来给`v-show`赋值，判断是否显示footer组件

`src/router/index.js`

```js
    routes: [
        {
            path: '/home',
            component: Home,
            meta: {isShowFooter: true}
        },
        {
            path: '/search',
            component: Search,
            meta: {isShowFooter: true}
        },
        {
            path: '/login',
            component: Login,
            meta: {isShowFooter: false}
        },
        {
            path: '/register',
            component: Register,
            meta: {isShowFooter: false}
        },
        // 重定向，在项目跑起来的时候，访问"/"，立马定向到首页
        {
            path: '*',
            redirect: '/home'
        }
    ]
```

`src/App.vue`

```vue
<Footer v-show="$route.meta.isShowFooter"/>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230420210510513.png" alt="image-20230420210510513" style="zoom:50%;" />

# 7. 路由传参

## 7.1 query、params参数

* query、params两个属性可以传递参数

  * query参数：不属于路径的一部分，类似于get请求，地址栏表现为`...8080/#/search?k1=v1&k2=v2`
  * query参数对应的路由信息：`path: "/search"`
  * params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要**占位**，地址栏表现为`...8080/#/search/v1/v2`
  * params参数对应的路由信息要修改为：`path: "/search/:keyWord"`这里的`/:keyWord`就是一个params参数的占位符

  **与路由传参的四个相关面试题：**

* 路由传递参数（对象写法）path是否可以结合params参数一起使用？

`src/components/Header/index.vue`

```js
      // 答：路由跳转传参的时候，对象的写法可以使name、path形式，但是需要注意的是：path这种写法是不能与params参数一起使用
      this.$router.push({
        path: '/search',
        params: {keyWord: this.keyWord},
        query: {k: this.keyWord.toUpperCase()}
      })
```

* 如何指定params参数可传可不传？

```js
  如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下：
  Search路由项的path已经指定要传一个keyword的params参数，如下所示：
  path: "/search/:keyword",
  执行下面进行路由跳转的代码：
  this.$router.push({name:"Search",query:{keyword:this.keyword}})
  当前跳转代码没有传递params参数
  地址栏信息：http://localhost:8080/#/?keyword=asd
  此时的地址信息少了/search
  正常的地址栏信息: http://localhost:8080/#/search?keyword=asd
  解决方法：可以通过改变path来指定params参数可传可不传 
  path: "/search/:keyword?",?表示该参数可传可不传
```

参考连接：https://blog.csdn.net/weixin_44867717/article/details/109773945

* 前面知道了params可传可不传 ，但是如果传递的是空串，如何解决？

```js
 this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''}})
 出现的问题和2中的问题相同,地址信息少了/search
 解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常
 this.$router.push({name:"Search",query:{keyword:this.keyword},params:{keyword:''||undefined}})

```

* 路由组件能不能传递props数据？

答： 可以，有三种写法，需要在路由器中配置

`src/router/index.js`

```js
        {
            name: 'Search',
            path: '/search/:keyWord?',
            component: Search,
            meta: {isShowFooter: true},
            // 路由组件可以传递props数据
            // 1.对象写法 额外给路由组件传递一些props
            // props: {a: 1, b: 'hello'},
            // 2.布尔值写法 如果为true，会把传的params以props形式接收
            // props: true,
            // 3.函数写法 可以把params参数、query参数通过props传递给路由组件
            props: ($route) => {
                return {
                    keyWord: $route.params.keyWord,
                    k: $route.query.k
                }
            }
        },
```

## 7.2 传参方法

* 字符串形式

```js
this.$router.push('/search/' + params传的参数 + '?k=' + query传的参数)
```

* 模板字符串

```js
this.$router.push(`/search/${this.params传的参数}?k=${this.query传的参数}`)
```

**注意**： 上面字符串的传参方法可以看出params参数和’/'结合，query参数和？结合
`http://localhost:8080/#/search/asd?keyword=asd`
上面url可以看出，asd为params的值，keyword=asd为query传递的值

* 对象（常用）

```js
      this.$router.push({
        name: '路由名字',
        params: {传的参数},
        query: {传的参数}
      })
```

**注意：**以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path 

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421165927432.png" alt="image-20230421165927432" style="zoom:50%;" />

# 8. 多次执行相同的push问题

多次执行相同的push问题，控制台会发生警告

例如：使用`this.$router.push({name:‘Search’,params:{keyword:“…”||undefined}})`时，如果多次执行相同的push，控制台会出现警告

我们尝试将其打印：

`src/components/Header/index.vue`

```js
let result = this.$router.push({
		name:"Search",
		query:{keyword:this.keyword}
})
console.log(result)
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d7b3e04b2986474d8009fe970b7b2e63.png)

多次执行则会出现警告

![在这里插入图片描述](https://img-blog.csdnimg.cn/308f41adccfe4268a6a2e0b4b2d2cfd0.png)

原因：push是一个`promise`，`promise`需要传递成功和失败两个参数，我们的push中没有传递。
方法：`this.$router.push({name:‘Search’,params:{keyword:“…”||undefined}},()=>{},()=>{})`后面两项分别代表执行成功和失败的回调函数。
这种写法治标不治本，将来在别的组件中push|replace,编程式导航还是会有类似错误
push是`VueRouter.prototype`的一个方法，在router中的`index.js`重写该方法即可(看不懂也没关系，这是前端面试题)

`src/router/index.js`

```js
// 先把VueRouter原型对象上的push保存一份
let originPush = VueRouter.prototype.push
let originReplace = VueRouter.prototype.replace
// 重写push|replace方法
// 第一个参数：告诉原来的push方法，往哪里跳转，传递哪些参数
// 第二个参数：成功的回调
// 第三个参数：失败的回调
VueRouter.prototype.push = function(location, resolve, reject) {
    if (resolve && reject) {
        // call/apply的区别：
        // 相同点：都可以调用函数一次，都可以篡改函数的上下文一次
        // 不同点：call与apply传递参数：call传递参数用逗号隔开，apply方法执行，传递数组
        originPush.call(this, location, resolve, reject)
    }else{
        originPush.call(this, location, () => {}, () => {})
    }
}
VueRouter.prototype.replace = function(location, resolve, reject) {
    if (resolve && reject) {
        originReplace.call(this, location, () => {}, () => {})
    }else{
        originReplace.call(this, location, () => {}, () => {})
    }
}
```

# 9. 定义全局组件

经过分析，我们的在Home下的三级联动组件是全局组件，全局的配置都需要在`main.js`中配置

我们将三级联动组件命名为`TypeNav.vue`

`src/main.js`

```js
// 三级联动组件---全局组件
import TypeNav from '@/pages/Home/TypeNav'
// 第一个参数：全局组件的名字 第二个参数：哪一个组件
Vue.component(TypeNav.name, TypeNav)
```

在Home组件中使用该全局组件（以后还要在Search、Detail中使用）

```vue
<template>
<div>
<!--  三级联动全局组件已经注册为全局组件，因此不需要引入-->
  <TypeNav/>
</div>
</template>
```

全局组件可以在任一页面中直接使用，不需要导入声明
下面全部商品分类就是三级联动组件

![image-20230421185308594](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185308594.png)

另外，我们也完成了主页Home的其他子组件的配置，整个静态页面搭建完成

`src/pages/Home/index.vue`

```vue
<template>
  <div>
    <!-- 三级联动全局组件 它已经注册为全局组件了，因此不需要引入 -->
    <TypeNav/>
    <!-- 其他子组件 -->
    <ListContainer/>
    <TodayRecommend/>
    <Rank/>
    <Like/>
    <Floor/>
    <Floor/>
    <Brand/>
  </div>
</template>

<script>
// 引入其余的组件
import ListContainer from '@/pages/Home/ListContainer'
import TodayRecommend from '@/pages/Home/TodayRecommend'
import Rank from '@/pages/Home/Rank'
import Like from '@/pages/Home/Like'
import Floor from '@/pages/Home/Floor'
import Brand from '@/pages/Home/Brand'
export default {
  name: 'Home',
  components: {
    ListContainer,
    TodayRecommend,
    Rank,
    Like,
    Floor,
    Brand
  }
}
</script>

<style>

</style>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185427694.png" alt="image-20230421185427694" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421185441827.png" alt="image-20230421185441827" style="zoom:50%;" />

其余组件关于静态页面的代码太多，就不放在笔记上了

# 10. 封装axios

axios中文文档，包含详细信息。
https://www.kancloud.cn/yunye/axios/234845
在根目录下创建api文件夹，创建request.js文件。
内容如下，当前文件代码还比较少，后续有需求可以增添内容。

安装axios

```shell
npm i axios
```

`src/api/request.js`

```js
// 对于axios进行二次封装
import axios from "axios";

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/api
    baseURL: '/api',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
// 请求拦截器：在发请求之前，它可以检测到，并做一些事情
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token
    return config
})
// 响应拦截器
requests.interceptors.response((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器相应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

# 11. 前端通过代理解决跨域问题

在api文件夹中统一管理请求，把它们封装成函数，调用则发请求

**将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可**

`src/api/index.js`

```js
// 当前模块，所有的API接口进行统一管理
import requests from "./request";

// 三级联动的接口
// /api/product/getBaseCategoryList 是get请求 无参数
export const reqCategoryList = () => {
    // 发请求：axios发请求返回的结果是Promise对象
    // 必须把服务器响应的数据返回供其他组件和模块使用
    return requests({
        method: 'GET',
        url: '/product/getBaseCategoryList', 
    })
}
```

在main.js进行发送请求的测试

`src/main.js`

```js
// 测试
import { reqCategoryList } from "@/api";
reqCategoryList()
```

由于我们本地和需要获取数据的服务器不同源，存在跨域问题，我们的请求必定失败

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204511275.png" alt="image-20230421204511275" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204537115.png" alt="image-20230421204537115" style="zoom:50%;" />

要解决跨域问题，我们需要使用webpack为我们提供的解决跨域方案：代理服务器。

在根目录下的`vue.config.js`中配置，`proxy`为通过代理解决跨域问题，关于原理我们可以在基础课上看到

我们在二次封装axios的时候已经设置了`baseURL`为：`"/api"`，所以我们所有的请求都会携带`/api`，这里我们就将`/api`进行了转换。如果你的项目没有封装axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为`/api`。

`src/vue.config.js`

```js
const { defineConfig } = require('@vue/cli-service')
module.exports = defineConfig({
  transpileDependencies: true,
  // 关闭eslint
  lintOnSave: false,
  // 代理服务器解决跨域
  devServer: {
    proxy: {
      // 检测到请求URL中带/api，代理服务器就会介入工作
      '/api': {
        // 真实服务器（数据存放的）的url
        target: 'http://gmall-h5-api.atguigu.cn',
        // 二次封装的axios全部请求路径已经带了api，这里不需要重写路径
        // pathRewrite: {'^/api': ''}
      }
    }
  }
})

```

跨域问题得到了解决，我们成功收到了服务器所响应的数据

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204659271.png" alt="image-20230421204659271" style="zoom:50%;" />

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230421204743534.png" alt="image-20230421204743534" style="zoom:50%;" />

## 12. nprogress进度条插件

当我们打开一个页面时，往往会伴随一些请求，并且会在页面的上方出现进度条。它的原理是：在我们发送请求的时候开启一个进度条，在请求成功后关闭进度条，所以只需要在`request.js`中相应的拦截器中进行配置

![在这里插入图片描述](https://img-blog.csdnimg.cn/f0df5bccfaee4274b45755b52bf40b60.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

`src/api/request.js`

```js
// 对于axios进行二次封装
import axios from "axios";
// 引入进度条
import nProgress from "nprogress";
// 引入进度条样式
import "nprogress/nprogress.css"
// start：进度条开始 done：进度条结束

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/api
    baseURL: '/api',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
/**
 * @description: 请求拦截器：在发请求之前，它可以检测到，并做一些事情
 * @return {*} 
 */
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token

    // 开启进度条
    nProgress.start()

    return config
})
/**
 * @description: 响应拦截器
 * @return {*}
 */
requests.interceptors.response.use((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    // 响应成功，关闭进度条
    nProgress.done()
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器响应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

也可以通过修改依赖中的nprogress.css的background来修改进度条颜色

```css
#nprogress .bar {
  background: #29d; /* 在这里修改 */

  position: fixed;
  z-index: 1031;
  top: 0;
  left: 0;

  width: 100%;
  height: 2px;
}
```

# 13. 手动引入Vuex

首先我们确保要在Vue2中使用Vuex3（3适配2 4适配3）

`src/store/index.js`

```js
import Vue from 'vue'
import Vuex from 'vuex'

Vue.use(Vuex)

//对外暴露store的一个实例
export default new Vuex.Store({
    state:{},
    mutations:{},
    actions:{},
    
})

```

如果想要在项目中使用Vuex，则需要在入口文件main.js引入并注册store

**但凡是在main.js中的Vue实例中注册的实体，在所有的组件中都会有（this.$.实体名）属性**

`src/main.js`

```js
import store from './store'
new Vue({
  render: h => h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')

```

​	我们的Vue提倡模块式开发 即那个组件用的数据就单独存放在哪个组件对应的数据流中

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424000248916.png" alt="image-20230424000248916" style="zoom:50%;" />

例如Home组件对应的数据流文件夹

`src/store/home/index.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-23 18:47:19
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-23 18:49:03
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/store/home/index.js
 * @Description: Home模块的小仓库
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */

// 仓库存储数据的地方
const state = {}
// 修改state的唯一手段
const mutations = {}
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {}
// getters理解为计算属性，更多用于简化仓库数据，让组件获取仓库的数据更加方便
const getters = {}

export default {
    namespaced: true,
    state,
    mutations,
    actions,
    getters
}
```

在Vuex中，模块化开发可以将store的代码拆分为多个模块，以便更好地管理和组织代码。而在模块化开发中，使用namespaced选项可以将模块的 actions、mutations 和 getters 封装到命名空间内，以避免不同模块之间的命名冲突。

具体来说，如果一个模块没有命名空间，它的 actions、mutations 和 getters 都会注册在全局命名空间中，这样可能会导致不同模块之间的方法名冲突，从而产生意外的结果。而使用namespaced选项后，所有的方法都会被封装到模块的命名空间下，这样就可以避免冲突，同时也更易于组织和维护代码。

因此，在模块化开发中，建议为每个模块添加namespaced选项，以便更好地管理代码和避免潜在的命名冲突

总的store：

`src/store/index.js`

```js
import Vue from "vue";
import Vuex from "vuex"
// 需要使用插件一次
Vue.use(Vuex)
// 引入小仓库
import home from './home'
import search from './search'

// 对外暴露Store类的一个实例
export default new Vuex.Store({
    // 实现Vuex仓库模块式开发存储数据
    modules: {
        home,
        search
    }
})
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424000410512.png" alt="image-20230424000410512" style="zoom:50%;" />

# 14. async await的使用

​	如果我们没有封装请求api，而是直接调用axios，就不需要使用async await了

案例：我们将一个axios请求封装为了函数，我们在下面代码中调用了该函数：

`src/store/home/index.js`

```js
import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/d2ba586e3edd494b9bf517cb4ee86580.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

返回了一个promise,证明这是一个promise请求，但是我们想要的是其中的data数据。
没有将函数封装前我们都会通过then()回调函数拿到服务器返回的数据，现在我们将其封装了，依然可以使用then获取数据，代码如下

```js
actions:{
        categoryList(){
            let result =  reqCateGoryList().then(
                res=>{
                console.log("res")
                console.log(res)
                return res
                }
            )
            console.log("result")
            console.log(result)
        }
    }

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/ccf35a9aa6c442c7a799e474c0293afa.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_15,color_FFFFFF,t_70,g_se,x_16)

由于我们的`promise`是异步请求，我们发现请求需要花费时间，但是它是异步的，所有后面的`console.log(“result”)`；`console.log(result)`会先执行，等我们的请求得到响应后，才执行`console.log(“res”)` `console.log(res)`这也符合异步的原则，但是我们如果在请求下面啊执行的是将那个请求的结果赋值给某个变量，这样就会导致被赋值的变量先执行，并且赋值为`undefined`，因为此时`promise`还没有完成。

![在这里插入图片描述](https://img-blog.csdnimg.cn/afe1c716352248009e7289151e933391.png)

所以我们引入了`async` `await`,async写在函数名前，await写在api函数前面。await含义是async标识的函数体内的并且在await标识代码后面的代码先等待await标识的异步请求执行完，再执行。这也使得只有`reqCateGoryList`执行完，`result `得到返回值后，才会执行后面的输出操作。


![在这里插入图片描述](https://img-blog.csdnimg.cn/160a7e87520d494787915f3fe9fa4640.png)

由此我们可以通过发送请求实现三级联动菜单显示服务器数据的操作：

`src/store/home/index.js`

```js
import { reqCategoryList } from "@/api";
// 仓库存储数据的地方
const state = {
    // state中数据的默认初始值别瞎写，根据接口的返回值来决定初始值
    categoryList: []
}
// 修改state的唯一手段
const mutations = {
    UPDATECATEGORYLIST(state, categoryList){
        state.categoryList = categoryList
    }
}
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {
    /**
     * @description: 通过API里面的接口函数调用，向服务器发请求，获取服务器的数据
     * @return {Object}
     */
    async categoryList(context){
        // 要拿到Promise成功的结果，需要加上await 前面需要加上async
        let result = await reqCategoryList()
        if (result.code === 200) {
            context.commit('UPDATECATEGORYLIST', result.data)
        }else{
            console.log('请求错误');
        }
    },
    // 通过then获取response也可以实现上面一模一样的效果，都是成功的回调，都是对象
    // categoryList(context){
    //     reqCategoryList().then(
    //         (res) => {
    //         if (res.code === 200) {
    //             context.commit('UPDATECATEGORYLIST', res.data)
    //         }
    //     },
    //         (error) => {
    //             console.log(error);
    //     })
    // },
}
```

这里事先将TypeNav这个导航组件移到了全局组件文件夹中

`src/components/TypeNav/index.vue`

```vue
<template>
  <!-- 商品分类导航 -->
  <div class="type-nav">
    <div class="container">
      <h2 class="all">全部商品分类</h2>
      <nav class="nav">
        <a href="###">服装城</a>
        <a href="###">美妆馆</a>
        <a href="###">尚品汇超市</a>
        <a href="###">全球购</a>
        <a href="###">闪购</a>
        <a href="###">团购</a>
        <a href="###">有趣</a>
        <a href="###">秒杀</a>
      </nav>
      <div class="sort">
        <div class="all-sort-list2">
          <div class="item" v-for="(c1, index) in categoryList" :key="c1.categoryId">
            <h3>
              <a href="">{{c1.categoryName}}</a>
            </h3>
            <div class="item-list clearfix">
              <div class="subitem" v-for="(c2, index) in c1.categoryChild" :key="c2.categoryId">
                <dl class="fore">
                  <dt>
                    <a href="">{{c2.categoryName}}</a>
                  </dt>
                  <dd>
                    <em v-for="(c3, index) in c2.categoryChild" :key="c3.categoryId">
                      <a href="">{{c3.categoryName}}</a>
                    </em>
                  </dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapState } from 'vuex';
export default {
  name: "TypeNav",
  /**
   * @description: 组件挂载完毕：可以向服务器发送请求
   * @return {*}
   */
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    this.$store.dispatch('home/categoryList')
  },
  computed: {
    ...mapState({
      // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数将会立即执行一次
      // 注入一个参数state，其实即为大仓库的数据
      categoryList: state => state.home.categoryList
    }),
  }
};
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424175101422.png" alt="image-20230424175101422" style="zoom:50%;" />

# 15. 事件委派实现导航栏选中

需求：完成以及分类动态添加背景颜色

第一种解决方案：采用css完成（可行）

```vue
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
            >
              <h3>
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
              <div class="item-list clearfix">
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a href="">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a href="">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
```

```css
.item {...}

.item:hover {
	background-color: skyblue;
}
```

可以实现需求<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424193924422.png" alt="image-20230424193924422" style="zoom:50%;" />





第二种解决方案：利用JS完成

解决思路是首先准备个data：`currentIndex`，我们收到的一些菜单是数组里的一个个对象，里面都有索引值，当我们鼠标移入(mouseenter)的时候，就可以将预先写好的类名对应的样式`.cur`赋给目标对象模板 

```vue
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
              :class="{ cur: currentIndex == index }"
            >
              <h3 @mouseenter="changeIndex(index)" @mouseleave="leaveIndex">
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
              <div class="item-list clearfix">
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a href="">{{ c2.categoryName }}</a>
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a href="">{{ c3.categoryName }}</a>
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
<script>
import { mapState } from "vuex";
export default {
  name: "TypeNav",
  data() {
    return {
      // 存储用户鼠标移上哪一个一级分类
      currentIndex: null,
    };
  },
  /**
   * @description: 组件挂载完毕：可以向服务器发送请求
   * @return {*}
   */
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    this.$store.dispatch("home/categoryList");
  },
  computed: {
    ...mapState({
      // 右侧需要的是一个函数，当使用这个计算属性的时候，右侧函数将会立即执行一次
      // 注入一个参数state，其实即为大仓库的数据
      categoryList: (state) => state.home.categoryList,
    }),
  },
  methods: {
    /**
     * @description: 鼠标进入修改响应式数据currentIndex
     * @param {*} index 鼠标移上某一个一级分类的元素索引值
     * @return {*}
     */
    changeIndex(index) {
      this.currentIndex = index;
    },
    /**
     * @description: 一级分类鼠标移出事件的回调
     * @return {*}
     */
    leaveIndex() {
      // 直接调用上面的函数，传入null更改currentIndex
      this.changeIndex(null);
    },
  },
};
</script>
<style>
          .cur {
          background-color: skyblue;
        }
</style>
```

这里有一个问题：当我们需要在我们的鼠标放入“全部商品分类”的这边区域的时候，蓝色背景还不消失，这时候我们需要用到事件委派了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230424194738978.png" alt="image-20230424194738978" style="zoom:50%;" />

由于红色导航栏和下面的蓝色区域是兄弟元素，我们需要把它们放在一起并且在它们俩的外面包上一层div，并且把鼠标离开的回调放在div上，实现事件委派

```vue
      <!-- 事件委派 鼠标离开h2和h3才会让currentIndex变回-1 -->
      <div @mouseleave="leaveIndex">
        <h2 class="all">全部商品分类</h2>
        <div class="sort">
          <div class="all-sort-list2">
             <h3 @mouseenter="changeIndex(index)">
                <a href="">{{ c1.categoryName }}-{{ index }}</a>
              </h3>
            ...
        </div>
      </div>
```

即可实现上述效果

# 16. 通过JS控制二三级分类显示与隐藏

项目的静态页面中，一开始我们是通过CSS样式`display:block|none`来控制显示与隐藏二三级商品分类的

​        <!-- 三级联动 -->
```vue
    <div class="sort">
      <div class="all-sort-list2">
        <div
          class="item"
          v-for="(c1, index) in categoryList"
          :key="c1.categoryId"
          :class="{ cur: currentIndex == index }"
        >
          <h3 @mouseenter="changeIndex(index)">
            <a href="">{{ c1.categoryName }}</a>
          </h3>
          <!-- 二级、三级分类 -->
          <div class="item-list clearfix">
           ...
          </div>
        </div>
      </div>
    </div>
```



```less
...

&hover {
	.item-list {
		display: block;
	}
}
```

我们可以删除掉这个less语句，通过`:style="JS表达式"`的方式，将样式交给Vue管理

```vue
          <!-- 二级、三级分类 -->
          <div class="item-list clearfix" :style="{display: currentIndex == index ? 'block' : 'none'}">
           ...
          </div>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425143056530.png" alt="image-20230425143056530" style="zoom:50%;" />

# 17. loadsh插件实现防抖和节流

在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率没有限制，就会加重浏览器的负担，导致用户体验非常的糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率的同时，又不影响实际效果

lodash官网：https://www.lodashjs.com/

**节流(throttle)：在规定的间隔事件范围内不会重复触发回调，只有大于这个时间间隔才会触发回调，把频繁触发变为少量触发**，用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码

节流函数：https://www.lodashjs.com/docs/lodash.throttle

**防抖(debounce)：前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发，也就是说如果连续快速的触发，只会执行一次**，用户操作很频繁，但是只执行一次，减少业务负担。

防抖函数：https://www.lodashjs.com/docs/lodash.debounce

节流和防抖简述：https://www.jianshu.com/p/c8b86b09daf0

Vue-cli中已经有了lodash模块儿，该插件提供了防抖和节流的函数，我们可以直接引入到js进行调用，当然也可以自己写【学会闭包+延时器】

例如：我们将三级联动菜单组件中的changeIndex函数设置了节流，如果操作很频繁，我们则限制50ms执行一次，由于要用到这个函数，我们必须在写methods的时候需要采用es5的键值对形式，throttle的返回值就是一个函数，所以直接使用键值对赋值，原函数的参数直接当成throttle的参数

```js
import throttle from 'lodash/throttle'
  methods: {
    /**
     * @description: 鼠标进入修改响应式数据currentIndex 没有给这个函数做节流
     * @param {*} index 鼠标移上某一个一级分类的元素索引值
     * @return {*}
     */
    // changeIndex(index) {
    //   // 正常情况（用户慢慢地操作）：鼠标进入，每一个一级分类h3都会触发鼠标进入事件
    //   // 非正常情况（用户操作很快）：本身全部的一级分类都应该触发鼠标进入事件，但是经过测试，只有部分的h3触发了
    //   // 就是因为用户行为过快，导致浏览器反应不过来。如果当前回调函数中有大量业务，就会出现卡顿
    //   this.currentIndex = index;
    // },
    
    // es6写法无法操作lodash的对象“_” 所以我们必须用es5的key:value写法
    /**
     * @description: 三级联动菜单中一级分类选中的节流
     * @param {Function} 需要做节流的函数
     * @param {[wait=0]} 在 wait 秒内最多执行 Function 函数
     * @return {*}
     */
    changeIndex: throttle(function(index){
      this.currentIndex = index
    }, 50),

    /**
     * @description: 一级分类鼠标移出事件的回调
     * @return {*}
     */
    leaveIndex() {
      // 直接调用上面的函数，传入null更改currentIndex
      this.changeIndex(null);
    },
  },
```

这样就可以节省性能提升用户体验

# 18. 编程式导航+事件委派实现路由跳转

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425191804385.png" alt="image-20230425191804385" style="zoom:50%;" />

如上图所示，我们页面中三级标签的列表非常多，每一个标签都是一个a标签，我们要实现通过点击a标签实现路由跳转

前面提到，我们实现路由跳转有两种方法：**声明式路由导航、编程式路由导航**

```markdown
对于声明式路由导航：我们有多少个a标签，就会生成多少个router-link标签，一个router-link标签我们可以把它当成组件，这样一千个a标签就会有一千多个router-link标签，我们在频繁操作的时候就会产生卡顿现象影响用户体验

对于编程式路由导航：我们是通过触发点击事件来实现的路由跳转。所以理论上有多少个a标签就会有多少个事件回调函数。虽然不会触发卡顿，但是也会影响性能
```

上面所说的方法无论采用哪一种，都会影响性能。于是我们提出一种：**编程式路由导航+事件委派**的方式来实现路由跳转。事件委派就是把子节点的触发事件都委托给父节点，这样只需要一个回调函数`goSearch`就能解决问题，谁需要这个事件的回调就给谁用

**然而使用事件委派就会产生新的问题：**

	* 如何确定我们点击的一定是a标签呢？如何保证我们只能通过点击a标签跳转呢？（因为只用事件委派，可以点击非a标签元素也实现跳转，这不符合我们的需求）
	* 如何获取子节点标签的商品名称和商品Id呢?（**我们是通过商品名称和商品Id进行页面跳转的**）

**解决办法：**

对于问题1：为三个等级的a标签添加自定义属性`data-categoryName`，用来绑定商品标签名称来标识a标签和其他标签

对于问题2：为三个等级的a标签分别添加自定义属性`data-category1Id`、`data-category2Id`、`data-category3Id`，来获取三个a标签的商品id，实现路由跳转

由于后端在传过来的数据中为每个a标签带了name和id，所以这几个自定义属性的值可以为对应的name和id

`/src/components/TypeNav/index.vue`

```vue
        <h2 class="all">全部商品分类</h2>
        <!-- 三级联动 -->
        <div class="sort">
          <!-- 事件委派 谁需要这个事件的回调就给谁用 -->
          <div class="all-sort-list2" @click="goSearch">
            <!-- 一级分类 -->
            <div
              class="item"
              v-for="(c1, index) in categoryList"
              :key="c1.categoryId"
              :class="{ cur: currentIndex == index }"
            >
              <h3 @mouseenter="changeIndex(index)">
                <a
                  :data-categoryName="c1.categoryName"
                  :data-category1Id="c1.categoryId"
                  >{{ c1.categoryName }}</a
                >
              </h3>
              <!-- 二级、三级分类 -->
              <div
                class="item-list clearfix"
                :style="{ display: currentIndex == index ? 'block' : 'none' }"
              >
                <div
                  class="subitem"
                  v-for="(c2, index) in c1.categoryChild"
                  :key="c2.categoryId"
                >
                  <dl class="fore">
                    <dt>
                      <a
                        :data-categoryName="c2.categoryName"
                        :data-category2Id="c2.categoryId"
                        >{{ c2.categoryName }}</a
                      >
                    </dt>
                    <dd>
                      <em
                        v-for="(c3, index) in c2.categoryChild"
                        :key="c3.categoryId"
                      >
                        <a
                          :data-categoryName="c3.categoryName"
                          :data-category3Id="c3.categoryId"
                          >{{ c3.categoryName }}</a
                        >
                      </em>
                    </dd>
                  </dl>
                </div>
              </div>
            </div>
          </div>
        </div>
```

**要注意的是，**e是事件对象，我们在函数定义的时候作为参数传入就可以了

```vue
//函数使用
<div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex">
//函数定义
goSearch(e){
      console.log(e.target)
    }

```

![在这里插入图片描述](https://img-blog.csdnimg.cn/4406011f40ab4b4db06e32974408ec1e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_12,color_FFFFFF,t_70,g_se,x_16)

相应的`goSearch`回调函数：

```js
    /**
     * @description: 路由跳转到的Search组件的回调
     * @return {*}
     */
    goSearch(e) {
      // 最好的解决方案：编程式路由导航+事件委派
      // 利用事件委派存在的一些问题：1.点击的不一定是a标签 2.如何获取参数【1、2、3级分类的产品名字、id】
      // 我们需要点击a标签的时候才会进行路由跳转【怎么能确定点击的一定是a标签】
      // 即使我们能确定点击的是a标签，是如何区分一级、二级、三级的a标签呢
      // 第一个问题：把子节点当中的a标签，加上我们自定义的属性data-categoryName，其余子节点是没有的
      // ES6写法：解构
      // html中会把大写转为小写
      let { categoryname, category1id, category2id, category3id } =
        e.target.dataset;
      //categoryname存在，表示为a标签
      if (categoryname) {
        // 整理路由跳转的参数
        let location = { name: "Search" }; // 路由跳转的name
        let query = { categoryName: categoryname }; // 路由的query参数
        if (category1id) {
          // category1id一级a标签
          query.category1Id = category1id;
        } else if (category2id) {
          // category2id二级a标签
          query.category2Id = category2id;
        } else {
          // category3id三级a标签
          query.category3Id = category3id;
        }
        // 整理完参数，将两个对象合二为一
        location.query = query;
        // 这样就可以携带query参数进行路由跳转操作
        this.$router.push(location);
      }
    },
```

这样可以在节省性能的同时只通过a标签跳转并且传递了query参数

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230425194040938.png" alt="image-20230425194040938" style="zoom:50%;" />

# 19. Search模块中商品分类与过渡动画

我们在home页面中点击每一个A标签都会携带query参数跳转到search页面，这个时候全局组件TypeNav就需要默认隐藏，并且我们需要在鼠标放到红色框框的时候用动画过渡出一级菜单

首先我们实现切到非home页面来隐藏一二三级菜单：

首先我们需要在组件里存一个布尔值来标识是否需要显示

`src/components/TypeNav/index.vue`

这里把之前写好的更改index的回调和隐藏分类菜单的回调合二为一

```js
<!-- 三级联动 -->
<!-- 过渡动画 -->
<div class="sort" v-show="isShow">
  ......
data() {
    return {
      // 存储用户鼠标移上哪一个一级分类
      currentIndex: null,
      // 存储是否显示一二三级菜单的标识
      isShow: true,
    };
  },
```

相应的两个进入和离开方法：

```vue
      <!-- 事件委派 鼠标离开h2和h3才会让currentIndex变回-1 以及离开或进入标题时h1的显示与隐藏 -->
      <div @mouseleave="leaveShow" @mouseenter="enterShow">
   		...
      <script>
        	methods: {
                /**
     						* @description: 当鼠标移入的时候，让商品分类列表进行展示
     						* @return {*}
     						*/
          enterShow() {
            this.isShow = true;
          },
        },
              /**
             * @description: 一级分类鼠标移出事件的回调 在Search组件有额外效果：移出不显示
             * @return {*}
             */
            leaveShow() {
              // 直接调用上面的函数，传入null更改currentIndex
              this.changeIndex(null);
              // 判断如果是非Home组件的时候才会执行
              if (this.$route.path != "/home") {
                this.isShow = false;
              }
            },
      }
      </script>
```

至此 我们就实现了切换页面自动隐藏分类菜单了

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230426185158279.png" alt="image-20230426185158279" style="zoom:50%;" />

接下来我们着手实现菜单的过渡动画

思路是使用我们Vue基础中讲过的安装第三方库`animate.css`并配合transition标签来使用

`scr/components/TypeNav.index.vue`

```vue
        <h2 class="all">全部商品分类</h2>
        <!-- 三级联动 -->
        <!-- 过渡动画 -->
        <transition
          name="animate__animated animate__bounce"
          enter-active-class="animate__fadeIn"
          leave-active-class="animate__fadeOut"
        >
          <div class="sort" v-show="isShow">
            <!-- 事件委派 谁需要这个事件的回调就给谁用 -->
            <div class="all-sort-list2" @click="goSearch">
              <!-- 一级分类 -->
              ...
                </div>
              </div>
            </div>
          </div>
        </transition>

...
import "animate.css";
```

在animate.css的文档中挑选好效果就可以实现需要的过渡效果了，我们这里选的是透明渐变

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230426185530521.png" alt="image-20230426185530521" style="zoom:50%;" />

# 20. Vue中路由销毁问题

首先我们要知道的一点：**Vue在路由切换的时候回销毁旧路由**

我们在三级列表的全局组件TypeNav中的mounted进行了请求一次商品分类列表数据

由于**Vue在路由切换的时候会销毁旧路由**，当我们再次使用一次三级列表组件的时候，由于组件的重新挂载，则会再发一次请求

如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求

![在这里插入图片描述](https://img-blog.csdnimg.cn/ea8ece30280d452b920c25ecbf1ed211.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

由于服务器返回的信息都是一样的，处于性能考虑，我们只希望这个数据只请求一次，所以我们把请求语句移动到了`App.vue`的mounted中（根组件App.vue的mounted只会执行一次）

**注意**：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性，main.js身上的this为undefined

`src/App.vue`

```vue
<script>
import Header from "./components/Header";
import Footer from "./components/Footer";
export default {
  name: "App",
  components: {
    Header,
    Footer,
  },
  mounted() {
    // 通知Vuex发请求，获取数据存储于仓库中
    // 使用命名空间后，必须指定某一个小仓库对应的actions
    // 把在TypeNav组件发的请求放到了全局组件App中，代表了只会发送一次，有利于性能节省
    this.$store.dispatch("home/categoryList");
  },
};
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230426201709074.png" alt="image-20230426201709074" style="zoom:50%;" />

# 21. 同时携带query和params参数

我们开发的项目目前位置，跳转到Search组件有两个方式：

	* 通过点击TypeNav组件中的商品分类菜单跳转
	* 通过点击Header组件中的搜索框实现跳转

当用户同时用了以上两种方式进行路由跳转到Search组件时，由于第一种方法传递的是query参数，第二种方法传递的是params参数，如果我们不判断的话，则很有可能造成另一种参数丢失

​	所以我们必须在每个路由跳转之前判断路径里面是否带有另一种参数

传query参数的同时判断是否有params参数：

`src/components/TypeNav/index.vue`

```js
...
    goSearch(e) {
      let { categoryname, category1id, category2id, category3id } =
        e.target.dataset;
      //categoryname存在，表示为a标签
      if (categoryname) {
        // 整理路由跳转的参数
        let location = { name: "Search" }; // 路由跳转的name
        let query = { categoryName: categoryname }; // 路由的query参数
				...
        // 判断：如果路由跳转带有了params参数，我们要捎带传递过去
        if (this.$route.params) {
          location.params = this.$route.params;
          // 整理完参数，将两个对象合二为一
          location.query = query;
          // 这样就可以携带query参数进行路由跳转操作
          this.$router.push(location);
        }
      }
    },
```

对应的，在传params参数的同时判断是否有query参数：

`src/components/Header/index.vue`

```js
...
    goSearch() {
      // 路由传递参数：
      // 第一种：字符串形式
      // this.$router.push('/search/' + this.keyWord + '?k=' + this.keyWord.toUpperCase())
      // 第二种：模板字符串
      // this.$router.push(`/search/${this.keyWord}?k=${this.keyWord.toUpperCase()}`)
      // 第三种：对象写法
      // 如果有query参数 则也带过去
      if (this.$route.query) {
        let location = {
          name: "Search",
          params: {
            keyWord: this.keyWord || undefined,
          },
        };
        location.query = this.$route.query;
        this.$router.push(location);
      }
    },
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230427170423073.png" alt="image-20230427170423073" style="zoom:50%;" />

这样既可以达成同时传参的目标

# 22. mock的使用

mock通常用来生成随机数据、拦截ajax请求，返回我们自定义的数据用于测试前端接口

我们将不同的数据封装为不同的json文件

这里我们为home页面上的ListContainer、Floor组件准备了数据

`/src/mock/banner.json`

```json
[
  {
    "id": "1",
    "imgUrl": "/images/banner1.jpg"
  },
  {
    "id": "2",
    "imgUrl": "/images/banner2.jpg"
  },
  {
    "id": "3",
    "imgUrl": "/images/banner3.jpg"
  },
  {
    "id": "4",
    "imgUrl": "/images/banner4.jpg"
  }
]

```

`src/mock/floor.json`

```json
[
  {
    "id": "001",
    "name": "家用电器",
    "keywords": [
      "节能补贴",
      "4K电视",
      "空气净化器",
      "IH电饭煲",
      "滚筒洗衣机",
      "电热水器"
    ],
    "imgUrl": "/images/floor-1-1.png",
    "navList": [
      {
        "url": "#",
        "text": "热门"
      },
      {
        "url": "#",
        "text": "大家电"
      },
      {
        "url": "#",
        "text": "生活电器"
      },
      {
        "url": "#",
        "text": "厨房电器"
      },
      {
        "url": "#",
        "text": "应季电器"
      },
      {
        "url": "#",
        "text": "空气/净水"
      },
      {
        "url": "#",
        "text": "高端电器"
      }
    ],
    "carouselList": [
      {
        "id": "0011",
        "imgUrl": "/images/floor-1-b01.png"
      },
      {
        "id": "0012",
        "imgUrl": "/images/floor-1-b02.png"
      },
      {
        "id": "0013",
        "imgUrl": "/images/floor-1-b03.png"
      }
    ],
    "recommendList": [
      "/images/floor-1-2.png",
      "/images/floor-1-3.png",
      "/images/floor-1-5.png",
      "/images/floor-1-6.png"
    ],
    "bigImg": "/images/floor-1-4.png"
  },
  {
    "id": "002",
    "name": "手机通讯",
    "keywords": [
      "节能补贴2",
      "4K电视2",
      "空气净化器2",
      "IH电饭煲2",
      "滚筒洗衣机2",
      "电热水器2"
    ],
    "imgUrl": "/images/floor-1-1.png",
    "navList": [
      {
        "url": "#",
        "text": "热门2"
      },
      {
        "url": "#",
        "text": "大家电2"
      },
      {
        "url": "#",
        "text": "生活电器2"
      },
      {
        "url": "#",
        "text": "厨房电器2"
      },
      {
        "url": "#",
        "text": "应季电器2"
      },
      {
        "url": "#",
        "text": "空气/净水2"
      },
      {
        "url": "#",
        "text": "高端电器2"
      }
    ],
    "carouselList": [
      {
        "id": "0011",
        "imgUrl": "/images/floor-1-b01.png"
      },
      {
        "id": "0012",
        "imgUrl": "/images/floor-1-b02.png"
      },
      {
        "id": "0013",
        "imgUrl": "/images/floor-1-b03.png"
      }
    ],
    "recommendList": [
      "/images/floor-1-2.png",
      "/images/floor-1-3.png",
      "/images/floor-1-5.png",
      "/images/floor-1-6.png"
    ],
    "bigImg": "/images/floor-1-4.png"
  }
]
```

安装mock

```shell
npm i mockjs
```

在文件夹里创建一个mock服务器

`src/mock/mockServer.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-27 17:52:55
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-27 18:08:59
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/mock/mockSever.js
 * @Description: mock模拟数据服务器
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */

// 先引入mockjs模块
import Mock from 'mockjs'
// 把JSON数据格式引入进来[JSON数据格式根本没有对外暴露，但是可以引入]
// webpack默认对外暴露的资源：图片、JSON数据格式
import banner from './banner.json'
import floor from './floor.json'

/**
 * @description: 模拟首页广告轮播图数据
 * @param {String} url 参数请求的地址
 * @param {Object} 请求的数据
 * @return {*}
 */
Mock.mock('/mock/banner', {code: 200, data: banner})

/**
 * @description: 模拟首页楼层数据
 * @param {String} url 参数请求的地址
 * @param {Object} 请求的数据
 * @return {*}
 */
Mock.mock('/mock/floor', {code: 200, data: floor})
```

既然是一个服务器，向外发送了请求，则需要在api文件夹里专门管理这些请求

这里我们与真实发送给服务器的文件相仿，创建了一个文件专门来处理和匹配发送给mock服务器的请求（和发送真实服务器的request.js文件相仿）

其实相对于request.js，就改了目标url

`/src/mockAjax.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-27 18:25:07
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-04-27 18:26:17
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/api/mockAjax.js
 * @Description: 使用mock发送模拟数据
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */
// 对于axios进行二次封装
import axios from "axios";
// 引入进度条
import nProgress from "nprogress";
// 引入进度条样式
import "nprogress/nprogress.css"
// start：进度条开始 done：进度条结束

// 1.利用axios对象的方法create，去创建一个axios实例
// 2.requests其实就axios，只不过咱们可以稍微配置一下
const requests = axios.create({
    // 配置对象
    // 基础路径，发请求的时候，路径当中会出现/mock
    baseURL: '/mock',
    // 代表请求超时的时间为5s
    timeout: 5000,
})
/**
 * @description: 请求拦截器：在发请求之前，它可以检测到，并做一些事情
 * @return {Object} 
 */
requests.interceptors.request.use((config) => {
    // config是一个配置对象，对象里面有一个属性很重要：headers请求头
    //config内主要是对请求头Header配置
    //比如添加token

    // 开启进度条
    nProgress.start()

    return config
})
/**
 * @description: 响应拦截器
 * @return {Object}
 */
requests.interceptors.response.use((response) => {
    // 请求成功的回调函数：服务器响应的数据回来以后，响应拦截器可以检测到并做一些事情
    // 响应成功，关闭进度条
    nProgress.done()
    return response.data
}, (error) => {
    // 请求失败的回调函数
    console.log("服务器响应失败" + error);
    // 这里终止Promise链
    return Promise.reject(new Error('Fail'))
})

// 对外暴露
export default requests
```

配置完这些后，我们可以在相应的组件中给mock服务器发送请求

`src/pages/Home/ListContainer/index.vue`

```js
  mounted() {
    this.$store.dispatch("home/getBannerList");
  },
```

既然在actions里我们发送了请求，根据项目的要求，我们得把这个请求函数放在api里统一管理

`src/api/index.js`

```js
import requests from "./request";
import mockRequests from './mockAjax'

/**
 * @description: 三级联动菜单的接口 是get请求 无参数
 * @url /api/product/getBaseCategoryList 
 * @return {Object: Promise}
 */
export const reqGetCategoryList = () => {
    // 发请求：axios发请求返回的结果是Promise对象
    // 必须把服务器响应的数据返回供其他组件和模块使用
    return requests({
        method: 'GET',
        url: '/product/getBaseCategoryList', 
    })
}

/**
 * @description: 轮播图的接口 是get请求 无参数
 * @url /mock/banner
 * @return {Object: Promise}
 */
export const reqGetBannerList = () => {
    return mockRequests({
        method: 'GET',
        url: '/banner'
    })
}
```

actions得在store里有相应的mutations以及数据流与其对应：

`/src/store/home/index.js`

```js
import { reqGetCategoryList, reqGetBannerList } from "@/api";
// 仓库存储数据的地方
const state = {
  // state中数据的默认初始值别瞎写，根据接口的返回值来决定初始值
  categoryList: [],
  bannerList: [],
};
// 修改state的唯一手段
const mutations = {
  //
  UPDATECATEGORYLIST(state, categoryList) {
    state.categoryList = categoryList;
  },
  UPDATEBANNERLIST(state, bannerList) {
    state.bannerList = bannerList;
  },
};
// 可以书写自己的业务逻辑，也可以处理异步
const actions = {
...
  /**
   * @description: 获取首页轮播图的数据
   * @param {*} context 上下文
   * @return {*}
   */
  getBannerList(context) {
    reqGetBannerList().then(
      (res) => {
        if (res.code === 200) {
          context.commit("UPDATEBANNERLIST", res.data);
        }
      },
      (error) => {
        console.log(error);
      }
    );
  },
};
```

然后再在相应组件中读取通过mock服务器返回并存放在state中数据

`src/pages/Home/ListContainer/index.vue`

```js
  ...
  computed: {
    ...mapState({
      // bannerList: (state) => {
      //   return state.home.bannerList
      // }
      bannerList: state => state.home.bannerList
    })
  },
  ...
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230427204551107.png" alt="image-20230427204551107" style="zoom:50%;" />

只要是公共数据都会放在store中，之后的实现步骤就是上面的固定步骤。

# 23. swiper插件实现轮播图

Swiper官网：https://www.swiper.com.cn/

官网中给出了代码案例

使用小结：

```
1. 安装swiper
2. 在需要使用轮播图的组件内导入swiper和它的css样式
3. 在组件中穿件swiper所需要的dom标签（html代码，参考官网使用说明）
4. 创建swiper实例
```

在通过举例复习swiper的使用后，我们接下来要考虑的是什么时候加载这个swiper，我们第一时间想到的是在`mounted`中创建这个实例，但是会出现无法加载轮播图片的问题

`src/pages/Home/ListContainer/index.vue`

```vue
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">
          <div class="swiper-wrapper">
            <div
              class="swiper-slide"
              v-for="(carousel, index) in bannerList"
              :key="carousel.id"
            >
              <img :src="carousel.imgUrl" />
            </div>
          </div>
          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
```

```js
mounted() {
	//请求数据
    this.$store.dispatch("getBannerList")
    console.log('初始化swiper实例')
    // ...相关的swiper轮播图操作
  },

```

结果发现无法使用轮播图，bannerList这个数据是通过Vuex拿来的，我们在相应的actions以及mutations做了调试打印来查看问题

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230430184106038.png" alt="image-20230430184106038" style="zoom:50%;" />



> 我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。

* 解决方法一：等我们数据请求完毕之后再创建swiper实例，加上一个时间延迟再创建swiper实例，将上面的代码改为：

```js
  mounted() {
    console.log('轮播图的mounted');
    this.$store.dispatch("home/getBannerList");
    // 在new Swiper实例之前，页面中的结构必须得先有 现在如果把new Swiper实例放在这里则不行
    // 因为dispatch当中涉及到异步语句，导致v-for遍历的时候结构还不完全
    setTimeout(() => {
      console.log('初始化swiper实例');
    }, 2000);
  },
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230430184733502.png" alt="image-20230430184733502" style="zoom:50%;" />

* 解决方法二：我们可以使用watch监听来自于仓库的bannerList轮播图列表属性，因为bannerList初始值为空，当它有数据的时候，我们就可以创建swiper对象

```js
  watch: {
    // 监听bannerList数据的变化
    bannerList: {
      /**
       * @description: 通过watch监听bannerList属性的属性值的变化，如果执行handler方法，代表组件实例身上这个属性的属性值已经有了变化
       * @param {*} newVal
       * @param {*} oldVal
       * @return {*}
       */
      handler(newVal, oldVal) {
					console.log('初始化Swiper实例')
        ...
        });
      },
    },
  },
```

> 这里的控制台和上图是一样的，但是还是无法实现轮播图 原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片（因为swiper对象生效的前提是html即dom结构已经渲染好了）

* **完美解决方案**：使用watch+[this.$nextTick()](https://cn.vuejs.org/v2/api/#vm-nextTick)
  官方介绍：this. $nextTick它会将回调延迟到下次 DOM **更新循环之后执行**（循环就是这里的v-for）。
  **个人理解**：无非是等我们页面中的结构都有了再去执行回调函数

完整代码：

`src/pages/Home/ListContainer/index.vue`

```vue
<template>
  <!--列表-->
  <div class="list-container">
    <div class="sortList clearfix">
      <div class="center">
        <!--banner轮播-->
        <div class="swiper-container" id="mySwiper">
          <div class="swiper-wrapper">
            <div
              class="swiper-slide"
              v-for="(carousel, index) in bannerList"
              :key="carousel.id"
            >
              <img :src="carousel.imgUrl" />
            </div>
          </div>
          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev"></div>
          <div class="swiper-button-next"></div>
        </div>
      </div>
      <div class="right">
        <div class="news">
          <h4>
            <em class="fl">尚品汇快报</em>
            <span class="fr tip">更多 ></span>
          </h4>
          <div class="clearix"></div>
          <ul class="news-list unstyled">
            <li><span class="bold">[特惠]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[公告]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[特惠]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[公告]</span>备战开学季 全民半价购数码</li>
            <li><span class="bold">[特惠]</span>备战开学季 全民半价购数码</li>
          </ul>
        </div>
        <ul class="lifeservices">
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">话费</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">机票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">电影票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">游戏</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">彩票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">加油站</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">酒店</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">火车票</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">众筹</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">理财</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">礼品卡</span>
          </li>
          <li class="life-item">
            <i class="list-item"></i>
            <span class="service-intro">白条</span>
          </li>
        </ul>
        <div class="ads">
          <img src="./images/ad1.png" />
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { mapState } from "vuex";
import Swiper from "swiper";
export default {
  name: "ListContainer",
  /**
   * @description: 派发actions，通过Vuex发起ajax请求，将数据存储在仓库中
   * @return {*}
   */
  mounted() {
    this.$store.dispatch("home/getBannerList");
    // 在new Swiper实例之前，页面中的结构必须得先有 现在如果把new Swiper实例放在这里则不行
    // 因为dispatch当中涉及到异步语句，导致v-for遍历的时候结构还不完全
  },
  computed: {
    ...mapState({
      // bannerList: (state) => {
      //   return state.home.bannerList
      // }
      bannerList: (state) => state.home.bannerList,
    }),
  },
  watch: {
    // 监听bannerList数据的变化
    bannerList: {
      /**
       * @description: 通过watch监听bannerList属性的属性值的变化，如果执行handler方法，代表组件实例身上这个属性的属性值已经有了变化
       * @param {*} newVal
       * @param {*} oldVal
       * @return {*}
       */
      handler(newVal, oldVal) {
        // 当前这个函数执行，只能保证bannerList数据已经有了，但是你没办法保证v-for已经执行结束了
        // v-for执行完毕才会有结构
        this.$nextTick(() => {
          // 当你真行这个回调的时候，保证服务器数据回来了，v-for执行完毕了【轮播图的解构一定会有的】
          var mySwiper = new Swiper(".swiper-container", {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
              clickable: true,
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
};
</script>
```

>  注意：之前我们在学习watch时，一般都是监听的定义在data中的属性，但是我们这里是监听的computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。

另外还有一个知识点提到：

在创建swiper对象时，我们会传递一个参数用于获取展示轮播图的DOM元素，官网直接通过class（而且这个class不能修改，是swiper的css文件自带的）获取。但是这样有缺点：当页面中有多个轮播图时，因为它们使用了相同的class修饰的DOM，就会出现所有的swiper使用同样的数据，这肯定不是我们希望看到的。
解决方法：在轮播图最外层DOM中添加ref属性

```html
<div class="swiper-container" id="mySwiper" ref="cur">
```

通过ref属性值获取DOM

```js
let mySwiper = new Swiper(this.$refs.cur,{...})
```

```vue
 <!--banner轮播-->
        <div class="swiper-container" id="mySwiper" ref="cur">

          <div class="swiper-wrapper">
            <div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id">
              <img :src="carouse.imgUrl" />
            </div>
          </div>

          <!-- 如果需要分页器 -->
          <div class="swiper-pagination"></div>

          <!-- 如果需要导航按钮 -->
          <div class="swiper-button-prev" ></div>
          <div class="swiper-button-next"></div>
        </div>
<script>
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
</script>

```

# 24. props父子组件通信

原理：父组件设置一个属性绑定要传递的数据

子组件通过props接受该属性值

父组件：Home

`src/pages/Home/index.vue`

```vue
<template>
<div>
//...省略
<!--  父组件通过自定义属性list给子组件传递数据-->
  <Floor v-for="item in floorList"  :key="item.id" :list="item"/>
<!--  商标-->
 
</div>
</template>


```

子组件Floor

`src/pages/Home/Floor/index.vue`

```vue
<template>
  <!--楼层-->
  <div class="floor">
    //...省略
  </div>
</template>

<script>
export default {
  name: "floor",
//子组件通过props属性接受父组件传递的数据
  props:['list']
}
</script>
```

第一张图是home组件的信息，我们的目的是将floorList中的数据分发给Floor组件

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f43c0c951b446ef92de7c00e37b05ee.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

![在这里插入图片描述](https://img-blog.csdnimg.cn/d1609e96dd89467c805ddef0bedf171a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

其实自己想的是使用全局事件总线解决，奈何总是在Floor组件接收到数据，无法把两个数据分配给两个不同的组件 所以就没有写下去了 但是学到了很多 

`src/pages/Home/index.vue`

```js
  methods: {
    // 自定义事件
    sendFloorListData() {
      this.$bus.$emit("getFloorListData", this.floorList);
      console.log("已发送");
    },
  },
  /**
   * @description: 视频里面使用的是props传参，我这里使用了全局事件总线，可能和ListContainer里面的v-for循环一样会有异步问题，这里仍然使用watch+nextTick来解决这个问题
   * @return {*}
   */
  watch: {
    floorList: {
      handler() {
        this.$nextTick(() => {
          this.sendFloorListData();
        });
      },
    },
  },
```

`src/pages/Home/Floor/index.vue`

```js
import Swiper from "swiper";
export default {
  name: "Floor",
  data() {
    return {
      dataList: [],
    };
  },
  mounted() {
    /**
     * @description: 执行自定义事件的回调，并接收传过来的数据
     * @return {*}
     */
    this.$bus.$on("getFloorListData", (data) => {
      this.dataList = data;
    });

    // 前面在ListContainer的mounted中使用swiper的时候是不可以的 为什么现在就可以了？
    // 因为在前面书写轮播图的时候，是在当前组件的内部发请求，动态渲染结构【前台至少服务器数据需要回来】，因此之前的写法是不行的
    // 现在的这种写法可以 是因为请求是父组件发的
    var mySwiper = new Swiper(".swiper-container", {
      loop: true, // 循环模式选项

      // 如果需要分页器
      pagination: {
        el: ".swiper-pagination",
        clickable: true,
      },

      // 如果需要前进后退按钮
      navigation: {
        nextEl: ".swiper-button-next",
        prevEl: ".swiper-button-prev",
      },
    });
  },
};
```

这里已经在dataList中拿到了数据 但是不知道怎么分配 以后可以去问一问

# 25. 将轮播图模块提取为公共组件

​	我们需要注意，我们要把定义swiper对象放在mounted中执行，并且还要设置`immediate: true`属性，这样可以实现无论数据有没有变化，上来立即监听一次

​	上面一节我们刚刚了解了props实现父组件向子组件传递信息，这里同样也会讲轮播图列表传递给子组件，原理相同

公共组件Carousel.vue

`src/components/Carousel/index.vue`

```vue
<template>
  <div class="swiper-container" id="floor1Swiper">
    <div class="swiper-wrapper">
      <div
        class="swiper-slide"
        v-for="(carousel, index) in carouselList"
        :key="carousel.id"
      >
        <img :src="carousel.imgUrl" />
      </div>
    </div>
    <!-- 如果需要分页器 -->
    <div class="swiper-pagination"></div>

    <!-- 如果需要导航按钮 -->
    <div class="swiper-button-prev"></div>
    <div class="swiper-button-next"></div>
  </div>
</template>

<script>
import Swiper from "swiper";
export default {
  name: "Carousel",
  props: ["carouselList"],
  watch: {
    carouselList: {
      // 立即监听一次 不管数据有没有变化
      immediate: true,
      // 为什么watch监听不到list：因为这个数据从来没有发生变化（数据是父组件给的，父组件给的时候就是一个对象）
      handler() {
        // 只能监听到数据已经有了，但是v-for动态渲染结构我们还是没有办法确定的，因此还是需要用nextTick
        this.$nextTick(function () {
          var mySwiper = new Swiper(".swiper-container", {
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: ".swiper-pagination",
              clickable: true,
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: ".swiper-button-next",
              prevEl: ".swiper-button-prev",
            },
          });
        });
      },
    },
  },
};
</script>
```

Floor组件可以直接使用封装过后的轮播图组件`Carousel`

`src/pages/Home/Floor/index.vue`

```vue
<!-- 轮播图 -->
<Carousel :carouselList="list.carouselList"/>
```

我们在首页的ListContainer中也使用到了轮播图 所以我们同样将里面的结构、代码替换为公共组件`Carousel`

`src/pages/Home/ListContainer/index.vue`

```vue
<!--banner轮播-->
<Carousel :carouselList="bannerList"/>
```

> 注意：
>
> * 老师将该组件在main.js中引入，并定义为全局组件。我这里只是在使用到该组件的地方引入并声明（个人认为轮播图组件还算不上全局组件）。
> * 引用组件时要在components中声明引入的组件
> * 我们将轮播图组件已经提取为公共组件Carousel，所、以我们只需要在Carousel中引入swiper和相应css样式。

# 26. Search组件商品列表的动态展示以及getters的使用

 我们已经开发完了Home组件，现在我们着手开始写Search的静态页面

`src/pages/Search/index.vue`

```vue
<template>
  <div>
    <TypeNav />
    <div class="main">
      <div class="py-container">
        <!--bread-->
        <div class="bread">
          <ul class="fl sui-breadcrumb">
            <li>
              <a href="#">全部结果</a>
            </li>
          </ul>
          <ul class="fl sui-tag">
            <li class="with-x">手机</li>
            <li class="with-x">iphone<i>×</i></li>
            <li class="with-x">华为<i>×</i></li>
            <li class="with-x">OPPO<i>×</i></li>
          </ul>
        </div>

        <!--selector-->
        <SearchSelector />

        <!--details-->
        <div class="details clearfix">
          <div class="sui-navbar">
            <div class="navbar-inner filter">
              <ul class="sui-nav">
                <li class="active">
                  <a href="#">综合</a>
                </li>
                <li>
                  <a href="#">销量</a>
                </li>
                <li>
                  <a href="#">新品</a>
                </li>
                <li>
                  <a href="#">评价</a>
                </li>
                <li>
                  <a href="#">价格⬆</a>
                </li>
                <li>
                  <a href="#">价格⬇</a>
                </li>
              </ul>
            </div>
          </div>
          <div class="goods-list">
            <ul class="yui3-g">
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <a href="item.html" target="_blank"><img src="./images/mobile01.png" /></a>
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile02.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile03.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile04.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile05.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile06.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile01.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile02.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile03.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
              <li class="yui3-u-1-5">
                <div class="list-wrap">
                  <div class="p-img">
                    <img src="./images/mobile04.png" />
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>6088.00</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">Apple苹果iPhone
                      6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)Apple苹果iPhone 6s (A1699)</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
            </ul>
          </div>
          <div class="fr page">
            <div class="sui-pagination clearfix">
              <ul>
                <li class="prev disabled">
                  <a href="#">«上一页</a>
                </li>
                <li class="active">
                  <a href="#">1</a>
                </li>
                <li>
                  <a href="#">2</a>
                </li>
                <li>
                  <a href="#">3</a>
                </li>
                <li>
                  <a href="#">4</a>
                </li>
                <li>
                  <a href="#">5</a>
                </li>
                <li class="dotted"><span>...</span></li>
                <li class="next">
                  <a href="#">下一页»</a>
                </li>
              </ul>
              <div><span>共10页&nbsp;</span></div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
  import SearchSelector from './SearchSelector/SearchSelector'
  export default {
    name: 'Search',

    components: {
      SearchSelector
    }
  }
</script>

<style lang="less" scoped>
  .main {
    margin: 10px 0;

    .py-container {
      width: 1200px;
      margin: 0 auto;

      .bread {
        margin-bottom: 5px;
        overflow: hidden;

        .sui-breadcrumb {
          padding: 3px 15px;
          margin: 0;
          font-weight: 400;
          border-radius: 3px;
          float: left;

          li {
            display: inline-block;
            line-height: 18px;

            a {
              color: #666;
              text-decoration: none;

              &:hover {
                color: #4cb9fc;
              }
            }
          }
        }

        .sui-tag {
          margin-top: -5px;
          list-style: none;
          font-size: 0;
          line-height: 0;
          padding: 5px 0 0;
          margin-bottom: 18px;
          float: left;

          .with-x {
            font-size: 12px;
            margin: 0 5px 5px 0;
            display: inline-block;
            overflow: hidden;
            color: #000;
            background: #f7f7f7;
            padding: 0 7px;
            height: 20px;
            line-height: 20px;
            border: 1px solid #dedede;
            white-space: nowrap;
            transition: color 400ms;
            cursor: pointer;

            i {
              margin-left: 10px;
              cursor: pointer;
              font: 400 14px tahoma;
              display: inline-block;
              height: 100%;
              vertical-align: middle;
            }

            &:hover {
              color: #28a3ef;
            }
          }
        }
      }

      .details {
        margin-bottom: 5px;

        .sui-navbar {
          overflow: visible;
          margin-bottom: 0;

          .filter {
            min-height: 40px;
            padding-right: 20px;
            background: #fbfbfb;
            border: 1px solid #e2e2e2;
            padding-left: 0;
            border-radius: 0;
            box-shadow: 0 1px 4px rgba(0, 0, 0, 0.065);

            .sui-nav {
              position: relative;
              left: 0;
              display: block;
              float: left;
              margin: 0 10px 0 0;

              li {
                float: left;
                line-height: 18px;

                a {
                  display: block;
                  cursor: pointer;
                  padding: 11px 15px;
                  color: #777;
                  text-decoration: none;
                }

                &.active {
                  a {
                    background: #e1251b;
                    color: #fff;
                  }
                }
              }
            }
          }
        }

        .goods-list {
          margin: 20px 0;

          ul {
            display: flex;
            flex-wrap: wrap;

            li {
              height: 100%;
              width: 20%;
              margin-top: 10px;
              line-height: 28px;

              .list-wrap {
                .p-img {
                  padding-left: 15px;
                  width: 215px;
                  height: 255px;

                  a {
                    color: #666;

                    img {
                      max-width: 100%;
                      height: auto;
                      vertical-align: middle;
                    }
                  }
                }

                .price {
                  padding-left: 15px;
                  font-size: 18px;
                  color: #c81623;

                  strong {
                    font-weight: 700;

                    i {
                      margin-left: -5px;
                    }
                  }
                }

                .attr {
                  padding-left: 15px;
                  width: 85%;
                  overflow: hidden;
                  margin-bottom: 8px;
                  min-height: 38px;
                  cursor: pointer;
                  line-height: 1.8;
                  display: -webkit-box;
                  -webkit-box-orient: vertical;
                  -webkit-line-clamp: 2;

                  a {
                    color: #333;
                    text-decoration: none;
                  }
                }

                .commit {
                  padding-left: 15px;
                  height: 22px;
                  font-size: 13px;
                  color: #a7a7a7;

                  span {
                    font-weight: 700;
                    color: #646fb0;
                  }
                }

                .operate {
                  padding: 12px 15px;

                  .sui-btn {
                    display: inline-block;
                    padding: 2px 14px;
                    box-sizing: border-box;
                    margin-bottom: 0;
                    font-size: 12px;
                    line-height: 18px;
                    text-align: center;
                    vertical-align: middle;
                    cursor: pointer;
                    border-radius: 0;
                    background-color: transparent;
                    margin-right: 15px;
                  }

                  .btn-bordered {
                    min-width: 85px;
                    background-color: transparent;
                    border: 1px solid #8c8c8c;
                    color: #8c8c8c;

                    &:hover {
                      border: 1px solid #666;
                      color: #fff !important;
                      background-color: #666;
                      text-decoration: none;
                    }
                  }

                  .btn-danger {
                    border: 1px solid #e1251b;
                    color: #e1251b;

                    &:hover {
                      border: 1px solid #e1251b;
                      background-color: #e1251b;
                      color: white !important;
                      text-decoration: none;
                    }
                  }
                }
              }
            }
          }
        }

        .page {
          width: 733px;
          height: 66px;
          overflow: hidden;
          float: right;

          .sui-pagination {
            margin: 18px 0;

            ul {
              margin-left: 0;
              margin-bottom: 0;
              vertical-align: middle;
              width: 490px;
              float: left;

              li {
                line-height: 18px;
                display: inline-block;

                a {
                  position: relative;
                  float: left;
                  line-height: 18px;
                  text-decoration: none;
                  background-color: #fff;
                  border: 1px solid #e0e9ee;
                  margin-left: -1px;
                  font-size: 14px;
                  padding: 9px 18px;
                  color: #333;
                }

                &.active {
                  a {
                    background-color: #fff;
                    color: #e1251b;
                    border-color: #fff;
                    cursor: default;
                  }
                }

                &.prev {
                  a {
                    background-color: #fafafa;
                  }
                }

                &.disabled {
                  a {
                    color: #999;
                    cursor: default;
                  }
                }

                &.dotted {
                  span {
                    margin-left: -1px;
                    position: relative;
                    float: left;
                    line-height: 18px;
                    text-decoration: none;
                    background-color: #fff;
                    font-size: 14px;
                    border: 0;
                    padding: 9px 18px;
                    color: #333;
                  }
                }

                &.next {
                  a {
                    background-color: #fafafa;
                  }
                }
              }
            }

            div {
              color: #333;
              font-size: 14px;
              float: right;
              width: 241px;
            }
          }
        }
      }
    }
  }
</style>
```

`src/pages/Search/SearchSelector/index.vue`

```vue
<template>
  <div class="clearfix selector">
    <div class="type-wrap logo">
      <div class="fl key brand">品牌</div>
      <div class="value logos">
        <ul class="logo-list">
          <li>索尼（SONY）</li>
          <li>TCL</li>
          <li>长虹（CHANGHONG）</li>
          <li>飞利浦（PHILIPS）</li>
          <li>风行电视</li>
          <li><img src="./images/phone06.png" /></li>
          <li><img src="./images/phone07.png" /></li>
          <li><img src="./images/phone08.png" /></li>
          <li><img src="./images/phone09.png" /></li>
          <li><img src="./images/phone10.png" /></li>
          <li><img src="./images/phone11.png" /></li>
          <li><img src="./images/phone12.png" /></li>
          <li><img src="./images/phone12.png" /></li>
          <li><img src="./images/phone14.png" /></li>
          <li><img src="./images/phone01.png" /></li>
          <li><img src="./images/phone06.png" /></li>
          <li><img src="./images/phone07.png" /></li>
          <li><img src="./images/phone02.png" /></li>
        </ul>
      </div>
      <div class="ext">
        <a href="javascript:void(0);" class="sui-btn">多选</a>
        <a href="javascript:void(0);">更多</a>
      </div>
    </div>
    <div class="type-wrap">
      <div class="fl key">网络制式</div>
      <div class="fl value">
        <ul class="type-list">
          <li>
            <a>GSM（移动/联通2G）</a>
          </li>
          <li>
            <a>电信2G</a>
          </li>
          <li>
            <a>电信3G</a>
          </li>
          <li>
            <a>移动3G</a>
          </li>
          <li>
            <a>联通3G</a>
          </li>
          <li>
            <a>联通4G</a>
          </li>
          <li>
            <a>电信3G</a>
          </li>
          <li>
            <a>移动3G</a>
          </li>
          <li>
            <a>联通3G</a>
          </li>
          <li>
            <a>联通4G</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
    <div class="type-wrap">
      <div class="fl key">显示屏尺寸</div>
      <div class="fl value">
        <ul class="type-list">
          <li>
            <a>4.0-4.9英寸</a>
          </li>
          <li>
            <a>4.0-4.9英寸</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
    <div class="type-wrap">
      <div class="fl key">摄像头像素</div>
      <div class="fl value">
        <ul class="type-list">
          <li>
            <a>1200万以上</a>
          </li>
          <li>
            <a>800-1199万</a>
          </li>
          <li>
            <a>1200-1599万</a>
          </li>
          <li>
            <a>1600万以上</a>
          </li>
          <li>
            <a>无摄像头</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
    <div class="type-wrap">
      <div class="fl key">价格</div>
      <div class="fl value">
        <ul class="type-list">
          <li>
            <a>0-500元</a>
          </li>
          <li>
            <a>500-1000元</a>
          </li>
          <li>
            <a>1000-1500元</a>
          </li>
          <li>
            <a>1500-2000元</a>
          </li>
          <li>
            <a>2000-3000元 </a>
          </li>
          <li>
            <a>3000元以上</a>
          </li>
        </ul>
      </div>
      <div class="fl ext">
      </div>
    </div>
    <div class="type-wrap">
      <div class="fl key">更多筛选项</div>
      <div class="fl value">
        <ul class="type-list">
          <li>
            <a>特点</a>
          </li>
          <li>
            <a>系统</a>
          </li>
          <li>
            <a>手机内存 </a>
          </li>
          <li>
            <a>单卡双卡</a>
          </li>
          <li>
            <a>其他</a>
          </li>
        </ul>
      </div>
      <div class="fl ext">
      </div>
    </div>
  </div>
</template>

<script>
  export default {
    name: 'SearchSelector',
  }
</script>

<style lang="less" scoped>
  .selector {
    border: 1px solid #ddd;
    margin-bottom: 5px;
    overflow: hidden;

    .logo {
      border-top: 0;
      margin: 0;
      position: relative;
      overflow: hidden;

      .key {
        padding-bottom: 87px !important;
      }
    }

    .type-wrap {
      margin: 0;
      position: relative;
      border-top: 1px solid #ddd;
      overflow: hidden;

      .key {
        width: 100px;
        background: #f1f1f1;
        line-height: 26px;
        text-align: right;
        padding: 10px 10px 0 15px;
        float: left;
      }

      .value {
        overflow: hidden;
        padding: 10px 0 0 15px;
        color: #333;
        margin-left: 120px;
        padding-right: 90px;

        .logo-list {
          li {
            float: left;
            border: 1px solid #e4e4e4;
            margin: -1px -1px 0 0;
            width: 105px;
            height: 52px;
            text-align: center;
            line-height: 52px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-weight: 700;
            color: #e1251b;
            font-style: italic;
            font-size: 14px;

            img {
              max-width: 100%;
              vertical-align: middle;
            }
          }
        }

        .type-list {
          li {
            float: left;
            display: block;
            margin-right: 30px;
            line-height: 26px;

            a {
              text-decoration: none;
              color: #666;
            }
          }
        }
      }

      .ext {
        position: absolute;
        top: 10px;
        right: 10px;

        .sui-btn {
          display: inline-block;
          padding: 2px 14px;
          box-sizing: border-box;
          margin-bottom: 0;
          font-size: 12px;
          line-height: 18px;
          text-align: center;
          vertical-align: middle;
          cursor: pointer;
          padding: 0 10px;
          background: #fff;
          border: 1px solid #d5d5d5;
        }

        a {
          color: #666;
        }
      }
    }
  }
</style>
```

至此静态页面我们就搭建完成 接下来我们需要做的是准备获取服务器请求以及让页面进行动态展示

封装发给服务器的请求，接口文档已经在Apifox中详细说明：

`src/api/index/js`

```js
/**
 * @description: 获取搜索模块数据 是post请求，需要带参数
 * @url /api/list
 * @param {*} params 至少是一个空对象 里面的参数可传可不传 参数示例:
 * {
    "category3Id": "61",
    "categoryName": "手机",
    "keyword": "小米",
    "order": "1:desc",
    "pageNo": 1,
    "pageSize": 10,
    "props": ["1:1700-2799:价格", "2:6.65-6.74英寸:屏幕尺寸"],
    "trademark": "4:小米"
    }
 * @return {Object: Promise}
 */
export const reqGetSearchInfo = (params) => {
    return requests({
        method: 'POST',
        url: '/list',
        data: params // 当前这个接口给服务器传递一个默认参数（params至少得是一个空对象 否则返回失败）
    })
}
```

紧接着我们就可以安排Vuex三连环：

`src/store/search/index.js`

```js
/*
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-04-23 18:47:22
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-05-02 17:26:06
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/store/search/index.js
 * @Description: Search模块的小仓库
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
 */

import { reqGetSearchInfo } from "@/api"

const state = {
    // 仓库初始状态
    searchList: {}
}
const mutations = {
    UPDATESEARCHLIST(state, searchList){
        state.searchList = searchList
    }
}
const actions = {
    /**
     * @description: 获取Search模块的数据
     * @param {*} context action中的上下文
     * @param {*} value 用户派发actions的时候，传递过来的需要用在我们接口中的参数（载荷），至少是一个空对象
     * @return {Object: Promise}
     */
    getSearchList(context, value = {}){
        // 这个函数在调用获取服务器数据的时候至少传递一个参数（空对象）
        reqGetSearchInfo(value).then(
            (res) => {
                if (res.code === 200) {
                    console.log(res);
                    context.commit('UPDATESEARCHLIST', res.data)
                }
            },
            (err) => {
                console.log(err);
            }
        )
    }
}

export default {
    namespaced: true,
    state,
    mutations,
    actions,
    getters
}
```

这个接口要求我们传入参数，至少是一个空对象，具体的成功示例是：

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230502173551474.png" alt="image-20230502173551474" style="zoom:50%;" />

data里面就包含着我们需要的数据

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230502173618043.png" alt="image-20230502173618043" style="zoom:50%;" />

如果我们就拿着这些数据在模板使用，则在mapState的时候会重复书写`state.searchList.xxxx`语句 为了简化代码，我们一般在仓库中先行包装好属性

> getters是vuex store中的计算属性。
> getters使用
> 如果不使用getters属性，我们在组件获取state中的数据表达式为：this.$store.state.子模块.属性，
> 如果有多个组件需要用到此属性，我们要么复制这个表达式，或者抽取到一个共享函数然后在多处导入它——无论哪种方式都不是很理想。
> Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
> 个人理解：getters将获取store中的数据封装为函数，代码维护变得更简单（和我们将请求封装为api一样）。而且getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。
> 注意：仓库中的getters是全局属性，是不分模块的。即store中所有模块的getter内的函数都可以通过$store.getters.函数名获取

我们在Search模块中获取商品列表数据就是通过getters实现，需要注意的是当网络出现故障时应该将返回值设置为空，如果不设置返回值就变成了undefined。

`src/store/search/index.js`

```js
// 计算属性，在项目当中是为了简化数据而生
// 可以把我们将来在组件当中需要用的数据简化一下【将来组件中获取数据的时候就方便了】
const getters = {
    /**
     * @description: getters简化数据 下同
     * @param {*} state 当前仓库中的state
     * @return {*}
     */
    goodsList(state){
        // 这样书写是有问题的 因为state中的数据有两种状态：空对象和一个包含服务器数据的对象
        // 如果是空对象的话，里面的goodList属性就为undefined 最后页面中如果要遍历undefined就会报错
        // 计算新的属性的属性值至少得来一个数组 以防万一
        return state.searchList.goodsList || []
    },
    trademarkList(state){
        return state.searchList.trademarkList || []
    },
    attrsList(state){
        return state.searchList.attrsList || []
    }
}
```

在对应组件中获取仓库的数据

`src/pages/Search/index.vue`

时间关系，这里我们先行动态展示goodsList的数据

```vue
          <!-- 销售产品列表 -->
          <div class="goods-list">
            <ul class="yui3-g">
              <li class="yui3-u-1-5" v-for="(good, index) in goodsList" :key="good.id">
                <div class="list-wrap">
                  <div class="p-img">
                    <a href="item.html" target="_blank">
                      <img :src="good.defaultImg" />
                    </a>
                  </div>
                  <div class="price">
                    <strong>
                      <em>¥</em>
                      <i>{{good.price}}</i>
                    </strong>
                  </div>
                  <div class="attr">
                    <a target="_blank" href="item.html" title="促销信息，下单即赠送三个月CIBN视频会员卡！【小米电视新品4A 58 火爆预约中】">{{good.title}}</a>
                  </div>
                  <div class="commit">
                    <i class="command">已有<span>2000</span>人评价</i>
                  </div>
                  <div class="operate">
                    <a href="success-cart.html" target="_blank" class="sui-btn btn-bordered btn-danger">加入购物车</a>
                    <a href="javascript:void(0);" class="sui-btn btn-bordered">收藏</a>
                  </div>
                </div>
              </li>
            </ul>
          </div>

...
<script>
  ...
      computed: {
      // 使用命名空间的简化写法
      // ...mapState('search', {
      //   goodsList: state => state.searchList.goodsList
      // })

      // 使用getters的简化写法 需要提前在仓库中配置好 第一个参数为命名空间 第二个为对应的getters
      ...mapGetters('search', ['goodsList'])
    }
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230502174202330.png" alt="image-20230502174202330" style="zoom:50%;" />

# 27. Object.assign实现对象拷贝

```js
Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】
举个栗子：
const object1 = {
  a: 1,
  b: 2,
  c: 3
};

const object2 = Object.assign({c: 4, d: 5}, object1);

console.log(object2.c, object2.d);
console.log(object1)  // { a: 1, b: 2, c: 3 }
console.log(object2)  // { c: 3, d: 5, a: 1, b: 2 }
```

> 注意：
> 1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性
> 2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标
> 对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如
> 果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到
> 原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。

深拷贝

```js
针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。
let obj1 = { a: 0 , b: { c: 0}}; 
let obj2 = Object.assign({}, obj1); 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj1.a = 1; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj2.a = 2; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}
 
obj2.b.c = 3; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}} 
最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响

// Deep Clone （深拷贝）
obj1 = { a: 0 , b: { c: 0}}; 
let obj3 = JSON.parse(JSON.stringify(obj1)); 
obj1.a = 4; 
obj1.b.c = 4; 
console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}

```

深拷贝目前只做了解即可

# 28. Search组件中传递真正的参数

现在我们就应该在给服务器的数据中夹带一点我们自定义的参数了 这些参数应该是来自query、params以及我们的keyword，他们都是路由跳转传过来的，代表着用户的行为

由于mounted钩子只会执行一次，我们需要将所有的参数提前准备好，在用户点击具体的路由跳转的时候，将参数覆盖给提前准备好的参数再给服务器传过去 只放在mounted中是不可行的

`src/pages/Search/index.vue`

```vue
 ...
 <script>
 data() {
    return {
      // 带给服务器的参数
      searchParams: {
        category1Id: "",
        category2Id: "",
        category3Id: "",
        categoryName: "",
        keyword: "",
        order: "",
        pageNo: 1,
        pageSize: 3,
        props: [],
        trademark: "",
      },
    };
  },
   </script>
```

这里我们根据接口文档准备并初始化了传给服务器的数据

接下来我们应该着手准备读取路由跳转中的数据并通过我们上面学过的Object.assign实现数据覆盖了

```js
  // 在组件挂载完毕之前执行一次 于mounted之前修改data中的数据
  created() {
    // 复杂的写法
    // this.searchParams.category1Id = this.$route.query.category1Id
    // this.searchParams.category2Id = this.$route.query.category2Id
    // this.searchParams.category3Id = this.$route.query.category3Id
    // this.searchParams.categoryName = this.$route.query.categoryName
    // this.searchParams.keyword = this.$route.params.keyword

    /**
     * @description: ES6新增语法，合并对象
     * @return {*}
     */
    Object.assign(this.searchParams, this.$route.query, this.$route.params)
  },
  mounted() {
    // 在发请求之前带给服务器的参数【searchParams参数发生变化】
    this.getData(this.searchParams);
  },
  methods: {
    /**
     * @description: 向服务器发请求获取search模块数据（根据参数不同返回不同的数据进行展示）
     * 把这个请求封装成一个函数，当需要发请求的时候调用即可
     * @return {Object}
     */
    getData(params) {
      // 派发action
      this.$store.dispatch("search/getSearchList", params);
    },
  },
};
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230502195600198.png" alt="image-20230502195600198" style="zoom:50%;" />

这样在我们点击的时候实现了带参数传给服务器，但是仅仅这样还有一个缺点：我们应该在用户每次点击的时候时时刻刻带参数发送请求给服务器然后重新展现页面显然我们只通过created、mounted这些钩子无法拒绝

# 29. Search子组件SearchSelector的数据动态展示

我们前面实现了Search组件商品列表的动态展示 现在我们着手实现其子组件`SearchSelector`的动态展示

其实就是拿到我们前面在getters里面维护好的`attrsList`和`trademarkList`然后通过v-for遍历模板，只需要仔细观察数据组成结构即可

`src/pages/Search/SearchSelector/index.vue`

```vue
<template>
  <div class="clearfix selector">
    <div class="type-wrap logo">
      <div class="fl key brand">品牌</div>
      <div class="value logos">
        <ul class="logo-list">
          <li v-for="(trademark, index) in trademarkList" :key="trademark.tmId">{{trademark.tmName}}</li>
        </ul>
      </div>
      <div class="ext">
        <a href="javascript:void(0);" class="sui-btn">多选</a>
        <a href="javascript:void(0);">更多</a>
      </div>
    </div>
    <div class="type-wrap" v-for="(attr, index) in attrsList" :key="attr.attrId">
      <div class="fl key">{{attr.attrName}}</div>
      <div class="fl value">
        <ul class="type-list">
          <li v-for="(attrValue, index) in attr.attrValueList" :key="index">
            <a>{{attrValue}}</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex'
  export default {
    name: 'SearchSelector',
    computed: {
      ...mapGetters('search', ['trademarkList', 'attrsList'])
    }
  }
</script>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230502203122368.png" alt="image-20230502203122368" style="zoom:50%;" />

# 30. 利用路由信息变化实现动态搜索

最初想法：在每个三级列表和收缩按钮加一个点击触发事件，只要点击了就执行搜索函数。
这是一个很蠢的想法，如果这样就会生成很多回调函数，很耗性能。
最佳方法：我们每次进行新的搜索时，我们的query和params参数中的部分内容肯定会改变，而且这两个参数是路由的属性。我们可以通过监听路由信息的变化来动态发起搜索请求。

如下图所示，$route是组件的属性，所以watch是可以监听的（watch可以监听组件data中所有的属性）
注意：组件中data的属性包括：自己定义的、系统自带的（如 $route）、父组件向子组件传递的等等

search中watch代码

`src/pages/Search/index.vue`

```js
  // 数据监听：监听组件实例身上的属性的属性值变化
  watch: {
    /**
     * @description: 监听路由的信息是否发生改变 如果发生变化则再次发请求
     * @param {*} newVal 发生变化后的$route
     * @param {*} oldVal 发生变化前的$route
     * @return {*}
     */
    $route(newVal, oldVal) {
      // 这里面数据结构简单，不需要使用深度监听
      // 再次发请求之前，我们需要整理带给服务器的参数
      Object.assign(this.searchParams, newVal.params, newVal.query);
      // 再次发请求
      this.getData(this.searchParams);
      // 每一次请求完毕，应该把相应的1、2、3级分类的id置空，让他能接受下一次相应的id
      this.searchParams.category1Id = '';
      this.searchParams.category2Id = '';
      this.searchParams.category3Id = '';
      // 下一次点击其他分类的时候清空关键词 因为不知道用户在搜索之后会点击哪个分类
      this.$route.params.keyword = '' || null
      // 为什么categoryName为什么不用置空？
      // 因为每一次路由发生变化的时候，这个属性值会发生变化
    },
  },
```

关于这里我们为置空keyword所发现的问题（个人想法）：

我们在进行search模块的开发的时候 不是有三级路由导航吗 我们每次点击商品分类的时候 都会传相应的categoryXId 比如我点三级标题手机 它会传category3Id

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230503141257794.png" alt="image-20230503141257794" style="zoom:50%;" />

由于我们在watch里面监听了$route这个对象的变化 每次在发送请求完毕之后 我们会故意清空1Id、2Id、3Id里面的值 让我们下一次点击其他级数的时候能够将原先的Id清除

果我们在点击3Id后 随后用户使用搜索框 搜索后就会引起keyword值的改变 所以点击之后就会带着3Id、categoryName、keyword这三个值提交给服务器

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230503141320801.png" alt="image-20230503141320801" style="zoom:50%;" />

如果在这个时候 用户点击了其他标题 比如二级商品 这也代表着 categoryName、category3Id将会发生变化 取而代之的是新的categoryName、新的category2Id、空的category3Id 老师在视频里明确说了categoryName和keyword不用专门置空，因为每一次路由发生变化的时候 这两个属性值会变化 但是我刚刚试了下 在我拥有3Id、keyword的情况下点击2Id后keyword的值不会发生变化 这是不是就代表着携带了错误的keyword提交给了服务器

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230503141339634.png" alt="image-20230503141339634" style="zoom:50%;" />

由于监听的特殊性，我们这里选择将route中的keyword改变 就可以解决问题

```js
      // 下一次点击其他分类的时候清空关键词 因为不知道用户在搜索之后会点击哪个分类
      this.$route.params.keyword = '' || null
```

点击3级标题的时候：

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230503141600677.png" alt="image-20230503141600677" style="zoom:50%;" />

随后点击2级标题：

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230503141619325.png" alt="image-20230503141619325" style="zoom:50%;" />

# 31. Search组件中面包屑相关操作

在这一节我们对面包屑操作主要是对query、params参数进行条件删除其中包括：

* 当分类属性（query）删除时删除面包屑同时修改路由信息
* 当搜索关键字（params）删除时删除面包屑、修改路由信息、同时删除输入框内的关键字

1. query删除时 

因为此部分在面包屑中是通过categoryName展示的，所所以删除时应将该属性值制空或undefined，可以通过路由再次跳转修改路由信息和url链接

`src/pages/Search/index.vue`

```vue
            <!-- 分类的面包屑 -->
            <li class="with-x" v-show="searchParams.categoryName">
              {{ searchParams.categoryName }}<i @click="removeBreadCategoryName">×</i>
            </li>

...
<script>
    methods: {
    
    /**
     * @description: 删除面包屑中分类名字的回调
     * @return {*}
     */
    removeBreadCategoryName() {
      // 和watch那里一样 把带给服务器的参数置空
      // 后台规定，带给服务器的参数是可有可无的，如果属性值为空的字符串还是会把相应的字段带给服务器
      // 如果把字段变成undefined，当前这个字段就不会返回给服务器
      this.searchParams.categoryName = "" || undefined;
      this.searchParams.category1Id = "" || undefined;
      this.searchParams.category2Id = "" || undefined;
      this.searchParams.category3Id = "" || undefined;
      // 路由参数变，watch里面会自动发请求，所以不需要额外发请求
      // this.getData(this.searchParams);
      // 地址栏也需要修改：进行路由跳转(自己跳自己)
      // 路由中包含params参数的情况
      if (this.$route.params) {
        this.$router.push({ name: "Search", params: this.$route.params });
      }
    },
  },
</script>
```

2. params删除时

和删除query相比，我们会多一步删除框内关键字的操作 ：删除输入框内的关键字（因为params参数是从输入框内获取的）

输入框在Header组件中 由于Header和Search是兄弟组件 所以得使用兄弟间组件通信

![在这里插入图片描述](https://img-blog.csdnimg.cn/86253180f85a48a3be90d98ea7d228ea.png)

我们这里通过全局事件总线实现 

1. 在main.js中安装全局事件总线

`src/main.js`

```js
new Vue({
  render: h => h(App),
  // 注册路由 以下的写法是key-value一致省略value
  router,
  // 注册仓库，组件实例的身上会多一个属性：$store
  store,
  // 安装全局事件总线
  beforeCreate(){
    Vue.prototype.$bus = this
  }
}).$mount('#app')
```

我们在Search组件中使用全局事件总线 

`src/pages/Search/index.vue`

```js
// 模板里的指定回调跟前面的categoryName面包屑是一样的
		/**
     * @description: 删除面包屑中关键字的回调
     * @return {*}
     */
    removeBreadKeyword(){
      // 给服务器带的searchParams中的keyword属性置空
      this.searchParams.keyword = '' || null
      // 这里也不需要额外发送请求，因为下面已经对路由进行了操作
      // this.getData(this.searchParams)
      // 既然用户都点击删除了关键字产生的面包屑，咱们自然而然应该清空搜索框的文字（v-model绑定了Header组件）
      // 使用全局事件总线通知兄弟组件Header清除keyword
      this.$bus.$emit('clearKeyword')
      // 进行路由的跳转
      // 地址栏也需要修改：进行路由跳转(自己跳自己)
      // 路由中包含query参数的情况
      if (this.$route.query) {
        this.$router.push({name: 'Search', query: this.$route.query})
      }
    }
```

3. 在Header组件中接受通信

`src/components/Header/index.vue`

```js
  mounted() {
    // 监听全局事件总线以清除关键字
    this.$bus.$on('clearKeyword', () => {
      this.keyword = ''
    })
  },
```

# 32. 组件间通信方式

1. 父子组件通信

> $on、$emit可以用自定义事件实现子组件向父组件传递信息 props实现父组件给子组件传递信息

2. 全局事件总线`$bus`（全能）
3. Vuex（全能）
4. 插槽（适用于父子组件在模板中通信）

# 33. SearchSelector子组件传参以及面包屑操作

我们在31节里面描述了通过query、params参数生成面包屑，以及面包屑的删除操作对应地址栏url的修改

SearchSelector组件有两个属性也会生成面包屑，分别为`trademarkName`、`attrValue`。如下图所示

![在这里插入图片描述](https://img-blog.csdnimg.cn/ff226e35cddc41948ddb1eb9d16395c5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5q-b5q-b6Jmr5ZGc5ZGc,size_20,color_FFFFFF,t_70,g_se,x_16)

此处生成面包屑时会涉及到子组件向父组件传递信息操作（在32小节有相关知识点），之后的操作和前面31小节讲的面包屑操作原理相同。唯一的区别是，这里删除面包屑时不需要修改地址栏url，因为url是由路由地址确定的，并且只有query、params两个参数变化回影响路由地址变化。
在具体的操作内还会涉及一些小的知识点，例如
字符串拼接 ·${}·，使用方法如下

```js
var a = 1;
console.log(`a的值是：${a}`); //a的值是：1
```

至此面包屑部分内容结束。
总结：面包屑由四个属性影响：parads、query、品牌、手机属性
**面包屑生成逻辑**
判断searchParams相关属性是否存在，存在即显示。
**面包屑删除逻辑**

`src/pages/Search/index.vue`

```vue
       <!-- 面包屑 全部结果这边的小叉叉标签 -->
        <div class="bread">
          <ul class="fl sui-breadcrumb">
            <li>
              <a href="#">全部结果</a>
            </li>
          </ul>
          <ul class="fl sui-tag">
            <!-- 分类categoryName的面包屑 -->
            <li class="with-x" v-show="searchParams.categoryName">
              {{ searchParams.categoryName
              }}<i @click="removeBreadCategoryName">×</i>
            </li>
            <!-- 关键字keyword的面包屑 -->
            <li class="with-x" v-show="searchParams.keyword">
              {{ searchParams.keyword }}<i @click="removeBreadKeyword">×</i>
            </li>
            <!-- 品牌trademark的面包屑 -->
            <li class="with-x" v-show="searchParams.trademark">
              {{ searchParams.trademark.split(":")[1]
              }}<i @click="removeBreadTrademark">×</i>
            </li>
            <!-- 商品属性attrId、attrName、attrValue的面包屑 由于props是数组 里面有多个元素的时候我们需要遍历生成多个面包屑 -->
            <li
              class="with-x"
              v-for="(attrItem, index) in searchParams.props"
              :key="attrItem.attrId"
            >
              {{ attrItem.split(":")[1] }}<i @click="removeBreadAttr(index)">x</i>
            </li>
          </ul>
        </div>
<script>
import { mapGetters } from "vuex";
import SearchSelector from "./SearchSelector";
export default {
  name: "Search",
  components: {
    SearchSelector,
  },
  data() {
    return {
      // 带给服务器的参数
      searchParams: {
        category1Id: "",
        category2Id: "",
        category3Id: "",
        categoryName: "",
        keyword: "",
        order: "",
        pageNo: 1,
        pageSize: 3,
        props: [],
        trademark: "",
      },
    };
  },
  // 在组件挂载完毕之前执行一次 于mounted之前修改data中的数据
  created() {
    // 复杂的写法
    // this.searchParams.category1Id = this.$route.query.category1Id
    // this.searchParams.category2Id = this.$route.query.category2Id
    // this.searchParams.category3Id = this.$route.query.category3Id
    // this.searchParams.categoryName = this.$route.query.categoryName
    // this.searchParams.keyword = this.$route.params.keyword

    /**
     * @description: ES6新增语法，合并对象
     * @return {*}
     */
    Object.assign(this.searchParams, this.$route.query, this.$route.params);
  },
  mounted() {
    // 在发请求之前带给服务器的参数【searchParams参数发生变化】
    this.getData(this.searchParams);
  },
  computed: {
    // 使用命名空间的简化写法
    // ...mapState('search', {
    //   goodsList: state => state.searchList.goodsList
    // })

    // 使用getters的简化写法 需要提前在仓库中配置好 第一个参数为命名空间 第二个为对应的getters
    ...mapGetters("search", ["goodsList"]),
  },
  methods: {
    /**
     * @description: 向服务器发请求获取search模块数据（根据参数不同返回不同的数据进行展示）
     * 把这个请求封装成一个函数，当需要发请求的时候调用即可
     * @return {Object}
     */
    getData(params) {
      // 派发action
      this.$store.dispatch("search/getSearchList", params);
    },

    /**
     * @description: 删除面包屑中分类名字的回调
     * @return {*}
     */
    removeBreadCategoryName() {
      // 和watch那里一样 把带给服务器的参数置空
      // 后台规定，带给服务器的参数是可有可无的，如果属性值为空的字符串还是会把相应的字段带给服务器
      // 如果把字段变成undefined，当前这个字段就不会返回给服务器
      this.searchParams.categoryName = "" || undefined;
      this.searchParams.category1Id = "" || undefined;
      this.searchParams.category2Id = "" || undefined;
      this.searchParams.category3Id = "" || undefined;
      // 路由参数变，watch里面会自动发请求，所以不需要额外发请求
      // this.getData(this.searchParams);
      // 地址栏也需要修改：进行路由跳转(自己跳自己)
      // 路由中包含params参数的情况
      if (this.$route.params) {
        this.$router.push({ name: "Search", params: this.$route.params });
      }
    },

    /**
     * @description: 删除面包屑中关键字的回调
     * @return {*}
     */
    removeBreadKeyword() {
      // 给服务器带的searchParams中的keyword属性置空
      this.searchParams.keyword = "" || null;
      // 这里也不需要额外发送请求，因为下面已经对路由进行了操作
      // this.getData(this.searchParams)
      // 既然用户都点击删除了关键字产生的面包屑，咱们自然而然应该清空搜索框的文字（v-model绑定了Header组件）
      // 使用全局事件总线通知兄弟组件Header清除keyword
      this.$bus.$emit("clearKeyword");
      // 进行路由的跳转
      // 地址栏也需要修改：进行路由跳转(自己跳自己)
      // 路由中包含query参数的情况
      if (this.$route.query) {
        this.$router.push({ name: "Search", query: this.$route.query });
      }
    },

    /**
     * @description: 子组件通过自定义事件给父组件传递过来的品牌数据
     * @param {*} trademark 子组件传入的对象
     * @return {*}
     */
    trademarkInfo(trademark) {
      // 整理品牌字段参数 "ID:品牌名称"
      this.searchParams.trademark = `${trademark.tmId}:${trademark.tmName}`;
      // 再次发请求 带刚刚拼接好的参数传给服务器 以达到搜索目的
      // 不需要判断是因为我们没有修改路由 不会引起watch的回调函数执行
      this.getData(this.searchParams);
    },

    /**
     * @description: 删除面包屑中品牌信息的回调
     * @return {*}
     */
    removeBreadTrademark() {
      // 置空
      // 这里如果用undefined或者null的话 由于v-show只是隐藏而不是销毁结构，所以会引起控制台警告 但是如果像我这样用空字符串的话不利于性能节省
      this.searchParams.trademark = "";
      // 再次发请求
      this.getData(this.searchParams);
    },

    /**
     * @description: 子组件通过自定义事件给父组件传递过来的商品属性数据
     * @param {*} attrId 子组件传过来的商品属性ID
     * @param {*} attrValue 子组件传过来的商品属性值
     * @param {*} attrName 子组件传过来的商品属性名
     * @return {*}
     */
    attrInfo(attrId, attrName, attrValue) {
      // 整理参数格式 ["属性ID:属性值:属性名"]
      const propElement = `${attrId}:${attrValue}:${attrName}`;
      // 由于props是数组 我们每次push之前需要进行判断是否有重复元素
      if (this.searchParams.props.indexOf(propElement) == -1) {
        this.searchParams.props.push(propElement);
        // 再次发请求 带刚刚拼接好的参数传给服务器 以达到搜索目的
        this.getData(this.searchParams);
      }
    },

    /** 
     * @description: 删除面包屑中商品属性的回调
     * @param {*} index 由于我们遍历了多个 所以删除的时候要传入被删除的那个元素的索引值
     * @return {*}
     */
    removeBreadAttr(index) {
      // const a = this.searchParams.props.filter((element) => {
      //   deletedPropElement == element
      // })
      // console.log(a);
      //  再次发请求
      // this.getData(this.searchParams);

      this.searchParams.props.splice(index, 1)
      this.getData(this.searchParams)
    },
  },
  // 数据监听：监听组件实例身上的属性的属性值变化
  watch: {
    /**
     * @description: 监听路由的信息是否发生改变 如果发生变化则再次发请求
     * @param {*} newVal 发生变化后的$route
     * @param {*} oldVal 发生变化前的$route
     * @return {*}
     */
    $route(newVal, oldVal) {
      // 这里面数据结构简单，不需要使用深度监听
      // 再次发请求之前，我们需要整理带给服务器的参数
      Object.assign(this.searchParams, newVal.params, newVal.query);
      // 再次发请求
      this.getData(this.searchParams);
      // 每一次请求完毕，应该把相应的1、2、3级分类的id置空，让他能接受下一次相应的id
      this.searchParams.category1Id = "" || undefined;
      this.searchParams.category2Id = "" || undefined;
      this.searchParams.category3Id = "" || undefined;
      // 下一次点击其他分类的时候清空关键词 因为不知道用户在搜索之后会点击哪个分类
      // 另外这里如果为undefined可能会导致removeCategoryName的路由跳转出现异常 所以用null占位
      // 这句代码需要注释 不然在我们清除面包屑的时候会连同query一起删除
      // this.$route.params.keyword = "" || null;
      // 为什么categoryName为什么不用置空？
      // 因为每一次路由发生变化的时候，这个属性值会发生变化
    },
  },
};
</script>
```

`src/pagrs/SearchSelector/index.vue`

```vue
<template>
  <div class="clearfix selector">
    <div class="type-wrap logo">
      <div class="fl key brand">品牌</div>
      <div class="value logos">
        <ul class="logo-list">
          <li v-for="(trademark, index) in trademarkList" :key="trademark.tmId" @click="trademarkHandler(trademark)">{{trademark.tmName}}</li>
        </ul>
      </div>
      <div class="ext">
        <a href="javascript:void(0);" class="sui-btn">多选</a>
        <a href="javascript:void(0);">更多</a>
      </div>
    </div>
    <!-- 平台售卖属性的地方 -->
    <div class="type-wrap" v-for="(attr, index) in attrsList" :key="attr.attrId">
      <div class="fl key">{{attr.attrName}}</div>
      <div class="fl value">
        <ul class="type-list">
          <!-- 平台相应售卖属性的属性值 如运行内存的4G、8G、16G 点击事件中我们点击属性值 要根据服务器接口传入相应的id name value -->
          <li v-for="(attrValue, index) in attr.attrValueList" :key="index" @click="attrHandler(attr.attrId, attr.attrName, attrValue)">
            <a>{{attrValue}}</a>
          </li>
        </ul>
      </div>
      <div class="fl ext"></div>
    </div>
  </div>
</template>

<script>
import { mapGetters } from 'vuex'
  export default {
    name: 'SearchSelector',
    computed: {
      ...mapGetters('search', ['trademarkList', 'attrsList'])
    },
    methods: {
      /**
       * @description: 点击品牌栏后的事件处理回调
       * @return {*}
       */
      trademarkHandler(trademark){
        // 在我们点击了品牌的东西之后，我们仍然需要整理参数，向服务器发送我们的请求
        // 我们应该在父组件Search发送请求，在这个子组件产生的数据我们必须传给父组件 我们可以使用自定义事件解决
        this.$emit('trademarkInfo', trademark)
      },

      /**
       * @description: 点击平台售卖属性后的事件处理回调
       * @param {*} attr 所点击属性值所属的那个对象 包含id 属性的key
       * @param {*} attrValue 具体的属性值 比如4G、8G
       * @return {*}
       */
      attrHandler(attrId, attrName, attrValue){
        // ["属性ID:属性值:属性名"]
        this.$emit('attrInfo', attrId, attrName, attrValue)
      }
    },
  }
</script>
```

这样就可以实现Search组件以及其子组件面包屑相关操作

# 34. 商品排序

​	我们的排序逻辑较为简单，改变一下请求中的order字段 后端会根据order的值来返回不同的数据实现升降序

order属性值为字符串，例如‘1：asc’、‘2：desc’。1代表综合，2代表价格，asc代表升序，desc代表降序

我们根据箭头图标来辨别升降序

![在这里插入图片描述](https://img-blog.csdnimg.cn/c8c9d5160f5847b18e0d5e31dc52c261.png)

我们按需引入ElementUI的箭头图标来标识升降序 具体使用请参考官网https://element.eleme.cn/#/zh-CN

`src/pages/Search/index.vue`

其中的结构

```vue
              <!-- 商品排序 -->
              <ul class="sui-nav">
                <!-- 表示当前这个属性里面包含1这个标识的时候赋予其active这个类名 -->
                <!-- 这里isOrderOne、isOrderTwo、isOrderAsc、isOrderDesc是计算属性，如果不使用计算属性，就要在页面中写很长的代码-->
                <li :class="{ active: isOrderOne }">
                  <!-- 使用了ElementUI组件库 -->
                  <a
                    >综合
                    <span
                      :class="{
                        'el-icon-top': isOrderAsc,
                        'el-icon-bottom': isOrderDesc,
                      }"
                      v-show="isOrderOne"
                    ></span
                  ></a>
                </li>
                <!-- 表示当前这个属性里面包含2这个标识的时候赋予其active这个类名 -->
                <li :class="{ active: isOrderTwo }">
                  <!-- 使用了ElementUI组件库 -->
                  <a
                    >价格
                    <span
                      :class="{
                        'el-icon-top': isOrderAsc,
                        'el-icon-bottom': isOrderDesc,
                      }"
                      v-show="isOrderTwo"
                    ></span
                  ></a>
                </li>
              </ul>
```

其中的计算属性代码：

```js
  computed: {
    /**
     * @description: 判断data中order这个属性里面有没有1这个标识 1代表选中综合
     * @return {Boolean} 用于class-active的布尔值
     */
    isOrderOne() {
      return this.searchParams.order.indexOf("1") != -1;
    },

    /**
     * @description: 判断data中order这个属性里面有没有2这个标识 2代表选中价格
     * @return {Boolean} 用于class-active的布尔值
     */
    isOrderTwo() {
      return this.searchParams.order.indexOf("2") != -1;
    },

    /**
     * @description: 判断data中order这个属性里面有没有asc这个标识 asc代表选升序 箭头向上
     * @return {*} 用于class-top的布尔值
     */
    isOrderAsc() {
      return this.searchParams.order.indexOf("asc") != -1;
    },

    /**
     * @description: 判断data中order这个属性里面有没有desc这个标识 desc代表选降序 箭头向下
     * @return {Boolean} 用于class-bottom的布尔值
     */
    isOrderDesc() {
      return this.searchParams.order.indexOf("desc") != -1;
    },
  },
```

点击综合或价格触发的函数changeOrder

```js
    /**
     * @description: 排序的操作
     * @param {*} flag 它是一个标记 代表用户点击的是综合（1）还是价格（2）【用户点击的时候传递】
     * @return {*}
     */
    changeOrder(flag){
      // 读取存放在data中的order
      let originOrder = this.searchParams.order
      let originFlag = originOrder.split(':')[0] // 1 或 2
      let originSort = originOrder.split(':')[1] // desc 或 asc
      let newOrder = ''
      // 判断的是多次点击的是不是同一个标签
      if (flag == originFlag) {
        newOrder = `${originFlag}:${originSort == 'desc'? 'asc': 'desc'}`
      }else{
        // 这是每次点击另一个标签会走的判断
        newOrder = `${flag}:${'desc'}` // 这里走完之后 下面会重新赋值 会引起originOrder、originFlag的变化，则如果我们点击了一次价格 下一次点击的话会走上面的if判断
      }
      // 将newOrder赋给searchParams 我们下一次进入这个函数的时候 originOrder、originFlag可能会是新的值
      this.searchParams.order = newOrder
      // 再次发请求
      this.getData(this.searchParams)
    }
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230509144900532.png" alt="image-20230509144900532" style="zoom:50%;" />

# 35. 全局组件分页器

像电商网站这种存放数据多地方，我们要将数据分页以减轻服务器的负担 所以需要用到分页器  ElementUI里面当然有现成的分页器 但是我们在这里准备自己写一写

我们在搜索界面、登录界面、支付界面都会用到这个组件 所以我们将把它定义为全局组件

`src/main.js`

```js
// 分页器组件---全局组件
import Pagination from '@/components/Pagination'
Vue.component(Pagination.name, Pagination)
```

相关静态页面

`src/components/Pagination/index.vue`

```vue
<!--
 * @Author: czqzzzzzz(czq)
 * @Email: tenchenzhengqing@qq.com
 * @Date: 2023-05-09 14:17:19
 * @LastEditors: czqzzzzzz(czq)
 * @LastEditTime: 2023-05-09 14:44:59
 * @FilePath: /尚硅谷VUE项目实战——尚品汇/app/src/components/Pagination/index.vue
 * @Description: 全局组件——分页器(Pagination)
 * 
 * Copyright (c) 2023 by czqzzzzzz(czq), All Rights Reserved. 
-->
<template>
  <div class="pagination">
    <button>上一页</button>
    <button>1</button>
    <button>···</button>

    <button>3</button>
    <button>4</button>
    <button>5</button>
    <button>6</button>
    <button>7</button>

    <button>···</button>
    <button>9</button>
    <button>下一页</button>

    <button style="margin-left: 30px">共 60 条</button>
  </div>
</template>

<script>
export default {
  name: "Pagination",
};
</script>

<style lang="less" scoped>
.pagination {
    text-align: center;
  button {
    margin: 0 5px;
    background-color: #f4f4f5;
    color: #606266;
    outline: none;
    border-radius: 2px;
    padding: 0 4px;
    vertical-align: top;
    display: inline-block;
    font-size: 13px;
    min-width: 35.5px;
    height: 28px;
    line-height: 28px;
    cursor: pointer;
    box-sizing: border-box;
    text-align: center;
    border: 0;

    &[disabled] {
      color: #c0c4cc;
      cursor: not-allowed;
    }

    &.active {
      cursor: not-allowed;
      background-color: #409eff;
      color: #fff;
    }
  }
}
</style>

```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230509145804753.png" alt="image-20230509145804753" style="zoom:50%;" />

 要写分页器 我们要知道几个核心属性：

|   属性    |           说明           |
| :-------: | :----------------------: |
|  pageNo   |         当前页码         |
| pageSize  | 当前页面所展示的数据数量 |
|   total   |        总数据数量        |
| continues |      连续展示的页码      |

我们现在手写分页器 注意里面的相关逻辑

`src/components/Pagination/index.vue`

```vue
<script>
export default {
  name: "Pagination",
  props: ["pageNo", "pageSize", "total", "continues"],
  computed: {
    /**
     * @description: 计算出总共的页数
     * @return {*}
     */
    totalPage() {
      // 向上取整
      return Math.ceil(this.total / this.pageSize);
    },
    /**
     * @description: 计算出连续的页码中起始数字与结束数字[连续的页码数至少为5]
     * @return {*}
     */
    startNumAndEndNum() {
      // 解构
      const { continues, pageNo, totalPage } = this;
      // 先定义两个变量存储起始页码和结束页码
      let start = 0,
        end = 0;
      // 当总页数没有连续页码数多的时候 走这个判断处理这个情况
      if (continues > totalPage) {
        start = 1;
        end = this.totalPage;
      } else {
        // 总页码数大于等于连续页码数
        // continues向下取整
        start = pageNo - Math.floor(continues / 2);
        end = pageNo + Math.floor(continues / 2);
        // start为负数或0的时候 我们需要纠正显示的分页
        if (start < 1) {
          start = 1;
          end = continues;
        }
        // 当end大于总页码的时候 我们需要纠正显示的分页
        if (end > totalPage) {
          end = totalPage;
          start = totalPage - continues + 1
        }
      }
    },
  },
};
</script>
```

这里面考虑到了各种情况 ：`当总页数没有连续页码数多的时候（特殊情况）`、`总页码数大于等于连续页码数的时候（一般情况）`、`当end大于总页码的时候（特殊情况）`

在模板里遍历页数的相关逻辑：

`src/components/Pagination/index/vue`

```vue
<template>
  <div class="pagination">
    <!-- 左边部分 -->
    <button>上一页</button>
    <button v-show="startNumAndEndNum.start > 1">1</button>
    <button v-show="startNumAndEndNum.start > 2">···</button>

    <!-- 中间部分 -->
    <button v-for="(page, index) in startNumAndEndNum.end" :key="index" v-show="page >= startNumAndEndNum.start">{{page}}</button>

    <!-- 下边部分 -->
    <button v-show="startNumAndEndNum.end < totalPage - 1">···</button>
    <button v-show="startNumAndEndNum.end < totalPage">{{ totalPage }}</button>
    <button>下一页</button>

    <button style="margin-left: 30px">共 {{ total }} 条</button>
  </div>
</template>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230509181408232.png" alt="image-20230509181408232" style="zoom:50%;" />

子组件通过自定义事件将要跳转的页码传给父组件并引起参数的改变最后再向服务器发去

子组件Pagination

`src/components/Pagination/index.vue`

```vue
<template>
  <div class="pagination">
    <!-- 左边部分 -->
    <button :disabled="pageNo == 1" @click="$emit('getPageNo', pageNo - 1)">上一页</button>
    <button v-show="startNumAndEndNum.start > 1" @click="$emit('getPageNo', 1)">1</button>
    <button v-show="startNumAndEndNum.start > 2">···</button>

    <!-- 中间部分 -->
    <button v-for="(page, index) in startNumAndEndNum.end" :key="index" v-show="page >= startNumAndEndNum.start" @click="$emit('getPageNo', page)">{{page}}</button>

    <!-- 下边部分 -->
    <button v-show="startNumAndEndNum.end < totalPage - 1">···</button>
    <button v-show="startNumAndEndNum.end < totalPage" @click="$emit('getPageNo', totalPage)">{{ totalPage }}</button>
    <button :disabled="pageNo == totalPage" @click="$emit('getPageNo', pageNo + 1)">下一页</button>

    <button style="margin-left: 30px">共 {{ total }} 条</button>
  </div>
</template>
```

父组件Search

`src/pages/Search/index.vue`

```vue
<template>
	 <!-- 分页器 -->
   <Pagination :pageNo="searchParams.pageNo" 			             :pageSize="searchParams.pageSize" :total="total" :continues="5" @getPageNo="getPageNo"/>
</template>
<script>
      /**
     * @description: 子组件Pagination通过自定义事件给父组件传递过来的当前页码
     * @param {*} receivedPageNo 从子组件接收到的当前页码
     * @return {*}
     */
    getPageNo(receivedPageNo){
      // 整理带给服务器的参数
      this.searchParams.pageNo = receivedPageNo
      // 再次发请求
      this.getData(this.searchParams)
    }
</script>
```

![image-20230510143728264](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230510143728264.png)

![image-20230510143750349](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230510143750349.png)

![image-20230510143808195](/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230510143808195.png)

最后我们只需要在模板中添加动态类名就可以了

```vue
<template>
  <div class="pagination">
    <!-- 左边部分 -->
    <button :disabled="pageNo == 1" @click="$emit('getPageNo', pageNo - 1)">
      上一页
    </button>
    <button
      v-show="startNumAndEndNum.start > 1"
      @click="$emit('getPageNo', 1)"
      :class="{ active: pageNo == 1 }"
    >
      1
    </button>
    <button v-show="startNumAndEndNum.start > 2">···</button>

    <!-- 中间部分 -->
    <button
      v-for="(page, index) in startNumAndEndNum.end"
      :key="index"
      v-show="page >= startNumAndEndNum.start"
      @click="$emit('getPageNo', page)"
      :class="{ active: pageNo == page }"
    >
      {{ page }}
    </button>

    <!-- 下边部分 -->
    <button v-show="startNumAndEndNum.end < totalPage - 1">···</button>
    <button
      v-show="startNumAndEndNum.end < totalPage"
      @click="$emit('getPageNo', totalPage)"
      :class="{ active: pageNo == totalPage }"
    >
      {{ totalPage }}
    </button>
    <button
      :disabled="pageNo == totalPage"
      @click="$emit('getPageNo', pageNo + 1)"
    >
      下一页
    </button>

    <button style="margin-left: 30px">共 {{ total }} 条</button>
  </div>
</template>
```

<img src="/Users/chenzhengqing/Library/Application Support/typora-user-images/image-20230510150720204.png" alt="image-20230510150720204" style="zoom:50%;" />

至此分页器效果完成 当然还有更多需要完善的地方 比如...可以点击等

# 36. 字符串拼接

如果你想在你的字符串内加入某个变量的值，就需要字符串拼接使用 ``（飘符号），

字符串拼接 ·${}·，使用方法如下：

在js中使用

```js
var a = 1;
console.log(`a的值是：${a}`); //a的值是：1

```

在html中使用

```vue
<router-link :to="`/detail/${goods.id}`"></router-link>
```

# 37. 滚动条

使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动。
[router滚动行为](https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html)
